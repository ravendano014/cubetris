<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Cubetris - Enhanced Version</title>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            touch-action: none;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            width: 250px;
            z-index: 10;
            user-select: none;
        }
        #levelComplete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 100;
            width: 300px;
        }
        button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 12px 24px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 8px 4px;
            cursor: pointer;
            border-radius: 8px;
            transition: background-color 0.3s;
            width: 100%;
        }
        button:hover {
            background-color: #45a049;
        }
        #controls {
            margin-top: 15px;
        }
        .control-btn {
            background-color: #2196F3;
        }
        .control-btn:hover {
            background-color: #0b7dda;
        }
        .align-btn {
            background-color: #FF9800;
            margin: 4px 2px;
            width: calc(33% - 8px);
            display: inline-block;
            padding: 8px 0;
        }
        .align-btn:hover {
            background-color: #F57C00;
        }
        .solve-btn {
            background-color: #9C27B0;
            margin-top: 10px;
        }
        .solve-btn:hover {
            background-color: #7B1FA2;
        }
        #alignControls {
            margin-top: 10px;
            text-align: center;
        }
        h2 {
            margin-top: 0;
            color: #4CAF50;
        }
        #errorMsg {
            position: absolute;
            top: 20px;
            right: 20px;
            transform: none;
            background-color: rgba(255,0,0,0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            display: none;
            text-align: center;
            max-width: 300px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .control-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        .control-row button {
            width: calc(50% - 5px);
            margin: 0;
            padding: 8px;
            font-size: 14px;
        }
        .large-btn {
            width: 100%;
        }
        .scatter-btn {
            background-color: #4CAF50;
        }
        .scatter-btn:hover {
            background-color: #45a049;
        }
        .check-btn {
            background-color: #F44336;
        }
        .check-btn:hover {
            background-color: #D32F2F;
        }
        .reset-btn {
            background-color: #007bff;
        }
        .reset-btn:hover {
            background-color: #0056b3;
        }
        .ok-btn {
            background-color: #FFC107;
        }
        .ok-btn:hover {
            background-color: #e0a800;
        }
        #onScreenControls {
            position: absolute;
            bottom: 120px;
            right: 220px;
            z-index: 10;
            display: grid;
            grid-template-columns: repeat(3, 120px);
            grid-template-rows: repeat(3, 120px);
            gap: 10px;
            background-color: rgba(0,0,0,0.6);
            padding: 20px;
            border-radius: 10px;
        }
        .dpad-btn {
            background-color: #333;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 36px;
            border-radius: 8px;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s;
        }
        #changePieceBtn { grid-area: 1 / 1 / 1 / 1; background-color: #17b4b2; font-size: 28px;}
        #changePieceBtn:hover { background-color: #00e5ff; }
        #moveUp { grid-area: 1 / 2 / 2 / 3; }
        #moveDown { grid-area: 3 / 2 / 4 / 3; } 
        #moveLeft { grid-area: 2 / 1 / 3 / 2; }
        #moveRight { grid-area: 2 / 3 / 3 / 4; }
        #moveForward { grid-area: 1 / 3 / 2 / 4; font-size: 28px;}
        #moveBackward { grid-area: 3 / 1 / 4 / 2; font-size: 28px;}
        #rotateBtn { grid-area: 2 / 2 / 3 / 3; background-color: #FF9800; font-size: 28px;}
        #rotateBtn:hover { background-color: #F57C00; }
        #fineTuneBtn { grid-area: 3 / 3 / 3 / 3; background-color: #d20f8a; font-size: 28px;}
        #fineTuneBtn:hover { background-color: #ff0090; }
        #progressBar {
            height: 10px;
            background-color: #333;
            border-radius: 5px;
            margin-top: 10px;
            overflow: hidden;
        }
        #progressFill {
            height: 100%;
            background-color: #4CAF50;
            width: 0%;
            transition: width 0.3s;
        }
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            color: white;
            text-align: center;
        }
        #startScreen h1 {
            color: #4CAF50;
            font-size: 3em;
            margin-bottom: 20px;
        }
        #startScreen p {
            max-width: 600px;
            margin-bottom: 30px;
            line-height: 1.6;
        }
        .dark-theme {
            background-color: #121212;
            color: #ffffff;
        }
        .light-theme {
            background-color: #f5f5f5;
            color: #333333;
        }
        #topCenterPanel {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 150;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: rgba(0,0,0,0.7);
            padding: 12px 20px;
            border-radius: 8px;
            min-width: 200px;
        }

        #topCenterPanel p {
            margin: 4px 0;
            font-size: 14px;
            text-align: center;
            color: white;
        }

        #topCenterControls {
            display: flex;
            gap: 10px;
            margin-top: 8px;
        }

        #themeToggle, #hintBtn, #captureBtn {
            background-color: #333;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            white-space: nowrap;
        }

        #themeToggle:hover, #hintBtn:hover, #captureBtn:hover {
            background-color: #555;
        }

        #onScreenControls {
            right: 20px;
        }
        #hintBtn {
            background-color: #9C27B0;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            width: 100%;
        }
        #hintBtn:hover {
            background-color: #7B1FA2;
        }
        #captureBtn {
            background-color: #2196F3;
        }
        #captureBtn:hover {
            background-color: #0b7dda;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
</head>
<body>
    <div id="startScreen">
        <h1>Cubetris</h1>
        <p>Welcome to Cubetris! Your goal is to assemble the scattered pieces back into a complete cube.</p>
        <p>Controls: Use the on-screen buttons or keyboard (WASD for movement, Q/E for forward/backward, R to rotate, Space to change piece, P to scatter, V to check, M for fine-tune mode).</p>
        <button id="startButton" style="padding: 15px 30px; font-size: 1.2em;">Start Game</button>
    </div>
    
    <canvas id="renderCanvas"></canvas>
    <div id="ui">
        <h2>Cubetris</h2>
        <div id="referenceImageContainer" style="display: none; margin-top: 10px; text-align: center;">
            <p style="margin-bottom: 5px; font-weight: bold;">Reference:</p>
            <img id="referenceImage" src="" alt="Assembled Cube Reference" style="width: 100%; border: 1px solid #555; border-radius: 5px;">
        </div>
        <div id="gameInfo">
            <p>Level: <span id="levelDisplay">1</span></p>
            <p>Fine Tune: <span id="fineTuneStatus">DEACTIVATED</span></p>
            <div id="progressBar">
                <div id="progressFill"></div>
            </div>
        </div>
        
        <div id="controls">
            <button class="control-btn scatter-btn" id="btnScatter">P <br>(Scatter)</button>
            <button class="control-btn check-btn" id="btnCheck">V <br>(Check)</button>
            <button class="control-btn ok-btn" id="btnItsOk">Its Ok for Me</button>
            <div class="control-row">
                <button id="resetCameraBtn" class="control-btn">Reset Camera</button>
                <button class="control-btn reset-btn" id="btnReset">Restart</button>
            </div>
            <button id="solveBtn" class="control-btn solve-btn">Solve <br>Puzzle</button>
        </div>
    </div>
    <div id="levelComplete">
        <h2>Level completed!</h2>
        <p>You have correctly assembled the cube.</p>
        <p>Time: <span id="levelTime">0</span>s</p>
        <p>Score: +<span id="levelScore">100</span></p>
        <button id="nextLevelBtn">Next level</button>
    </div>
    <div id="errorMsg"></div>

    <div id="onScreenControls">
        <div class="dpad-btn" id="changePieceBtn">Switch</div>
        <div class="dpad-btn" id="moveUp">&#9650;</div>
        <div class="dpad-btn" id="moveDown">&#9660;</div> 
        <div class="dpad-btn" id="moveLeft">&#9664;</div>
        <div class="dpad-btn" id="moveRight">&#9654;</div>
        <div class="dpad-btn" id="moveForward">Fwd Z</div>
        <div class="dpad-btn" id="moveBackward">Bwd Z</div>
        <div class="dpad-btn" id="rotateBtn">Rotate</div>
        <div class="dpad-btn" id="fineTuneBtn">FineTune</div>
    </div>

    <div id="topCenterPanel">
        <p>Cube: <span id="cubeSizeDisplay">3x3x3</span></p>
        <p>Score: <span id="scoreDisplay">0</span></p>
        <p>Time: <span id="timerDisplay">0s</span></p>
        <div id="topCenterControls">
            <button id="hintBtn">üí° Hint</button>
            <button id="captureBtn">üì∑ Capture</button>
            <button id="themeToggle">üåô Theme</button>
        </div>
    </div>

    <script>
        // Enhanced global variables
        const gameState = {
            canvas: null,
            engine: null,
            scene: null,
            camera: null,
            currentLevel: 1,
            pieces: [],
            selectedPieceIndex: 0,
            targetCubeSize: 3,
            isAnimating: false,
            gridSize: 1.0,
            isScattered: false,
            animationFrame: null,
            isFineTuneMode: false,
            lastClickTime: 0,
            doubleClickThreshold: 300,
            referenceImageTakenForCurrentAssembly: false,
            score: 0,
            levelStartTime: 0,
            currentTime: 0,
            timerInterval: null,
            moveHistory: [],
            maxUndoSteps: 20,
            soundEnabled: false,
            sounds: {},
            darkTheme: false,
            correctBlocks: 0,
            totalBlocks: 0
        };

        // Constants
        const COLORS = [
            new BABYLON.Color3(1, 0, 0),
            new BABYLON.Color3(0, 0, 1),
            new BABYLON.Color3(0, 1, 0),
            new BABYLON.Color3(1, 1, 0),
            new BABYLON.Color3(1, 0, 1),
            new BABYLON.Color3(0, 1, 1),
            new BABYLON.Color3(1, 0.5, 0),
            new BABYLON.Color3(0.5, 0, 0.5),
            new BABYLON.Color3(0, 0.5, 0),
            new BABYLON.Color3(0.8, 0.4, 0)
        ];

        // Texture URLs
        const TEXTURE_URLS = [
            "https://raw.githubusercontent.com/ravendano014/cubetris/refs/heads/main/cube.jpeg",
            "https://i.imgur.com/lXehwjZ.jpg",
            "https://i.imgur.com/7jDxfj0.jpg"
        ];

        // HDRI Environment Textures for PBR
        const HDRI_URLS = [
            "https://assets.babylonjs.com/environments/environmentSpecular.dds"
        ];

        // Scatter directions
        const SCATTER_DIRECTIONS = [
            new BABYLON.Vector3(1, 0, 0),
            new BABYLON.Vector3(-1, 0, 0),
            new BABYLON.Vector3(0, 1, 0),
            new BABYLON.Vector3(0, -1, 0),
            new BABYLON.Vector3(0, 0, 1),
            new BABYLON.Vector3(0, 0, -1)
        ];

        // Emissive colors for selection
        const NORMAL_EMISSIVE_COLOR = new BABYLON.Color3(0.3, 0.3, 0.3);
        const FINE_TUNE_EMISSIVE_COLOR = new BABYLON.Color3(0.5, 0.5, 0);
        const CORRECT_POSITION_COLOR = new BABYLON.Color3(0, 1, 0);

        // Initialize the game
        function initGame() {
            // Load sounds
            loadSounds();
            
            // Setup theme toggle
            document.getElementById('themeToggle').addEventListener('click', toggleTheme);
            
            // Setup start button
            document.getElementById('startButton').addEventListener('click', function() {
                document.getElementById('startScreen').style.display = 'none';
                startGame();
            });
            
            // Try to load saved game
            loadGame();
        }
        
        function startGame() {
            gameState.canvas = document.getElementById('renderCanvas');
            gameState.engine = new BABYLON.Engine(gameState.canvas, true, {
                preserveDrawingBuffer: true,
                stencil: true
            });
            gameState.scene = new BABYLON.Scene(gameState.engine);
            
            setupCamera();
            setupLights();
            setupScene();
            
            startLevel(gameState.currentLevel);
            
            setupControls();
            setupUI();
            setupPointerControls(); 
            
            gameState.engine.runRenderLoop(() => {
                gameState.scene.render();
            });
            
            window.addEventListener('resize', () => {
                gameState.engine.resize();
            });
        }
        
        function loadSounds() {
            gameState.sounds = {
                move: new Howl({ src: [''] }),
                rotate: new Howl({ src: [''] }),
                select: new Howl({ src: [''] }),
                success: new Howl({ src: [''] }),
                error: new Howl({ src: [''] }),
                scatter: new Howl({ src: [''] }),
                click: new Howl({ src: [''] })
            };
        }
        
        function playSound(soundName) {
            if (gameState.soundEnabled && gameState.sounds[soundName]) {
                gameState.sounds[soundName].play();
            }
        }
        
        function toggleTheme() {
            gameState.darkTheme = !gameState.darkTheme;
            const themeToggle = document.getElementById('themeToggle');
            if (gameState.darkTheme) {
                document.body.classList.add('dark-theme');
                document.body.classList.remove('light-theme');
                themeToggle.textContent = '‚òÄÔ∏è Theme';
            } else {
                document.body.classList.add('light-theme');
                document.body.classList.remove('dark-theme');
                themeToggle.textContent = 'üåô Theme';
            }
            saveGame();
        }

        function setupCamera() {
            gameState.camera = new BABYLON.ArcRotateCamera(
                "Camera", 
                -Math.PI / 2, 
                Math.PI / 3, 
                20, 
                BABYLON.Vector3.Zero(), 
                gameState.scene
            );
            gameState.camera.upperBetaLimit = Math.PI / 2;
            gameState.camera.lowerRadiusLimit = 5;
            gameState.camera.upperRadiusLimit = 25;
            gameState.camera.attachControl(gameState.canvas, true);
            gameState.camera.inputs.attached.keyboard.detachControl();
            
            gameState.camera.inertia = 0.8;
            gameState.camera.wheelPrecision = 50;
        }

        function setupLights() {
            new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), gameState.scene);
            const directionalLight = new BABYLON.DirectionalLight(
                "light2", 
                new BABYLON.Vector3(0, -1, 1), 
                gameState.scene
            );
            directionalLight.intensity = 0.7;
        }

        function setupScene() {
            gameState.scene.clearColor = new BABYLON.Color4(0.1, 0.1, 0.2, 1);
            gameState.scene.autoClear = true;
            gameState.scene.autoClearDepthAndStencil = true;
            
            gameState.scene.environmentTexture = new BABYLON.CubeTexture.CreateFromPrefilteredData(
                HDRI_URLS[0], 
                gameState.scene
            );
            gameState.scene.environmentTexture.gammaSpace = false;
            
            gameState.scene.imageProcessingConfiguration.contrast = 1.6;
            gameState.scene.imageProcessingConfiguration.exposure = 1;
            
            gameState.scene.postProcessRenderPipelineManager = new BABYLON.PostProcessRenderPipelineManager();
            gameState.scene.postProcessRenderPipelineManager.addPipeline(new BABYLON.OutlineRenderer(gameState.scene));
        }

        function createTargetCube() {
            const targetCube = BABYLON.MeshBuilder.CreateBox(
                "targetCube", 
                {size: gameState.targetCubeSize * gameState.gridSize}, 
                gameState.scene
            );
            targetCube.visibility = 0;
            
            const wireframe = BABYLON.MeshBuilder.CreateBox(
                "wireframe", 
                {size: gameState.targetCubeSize * gameState.gridSize}, 
                gameState.scene
            );
            const wireMat = new BABYLON.StandardMaterial("wireMat", gameState.scene);
            wireMat.wireframe = true;
            wireMat.emissiveColor = new BABYLON.Color3(0, 1, 0);
            wireMat.alpha = 0.3;
            wireframe.material = wireMat;
            
            document.getElementById('cubeSizeDisplay').textContent = 
                `${gameState.targetCubeSize}x${gameState.targetCubeSize}x${gameState.targetCubeSize}`;
        }

        function createGrid() {
            const halfSize = (gameState.targetCubeSize * gameState.gridSize) / 2;
            const lines = [];
            
            for (let x = -halfSize; x <= halfSize; x += gameState.gridSize) {
                lines.push([new BABYLON.Vector3(x, -halfSize, -halfSize), new BABYLON.Vector3(x, -halfSize, halfSize)]);
                lines.push([new BABYLON.Vector3(x, halfSize, -halfSize), new BABYLON.Vector3(x, halfSize, halfSize)]);
            }
            
            for (let z = -halfSize; z <= halfSize; z += gameState.gridSize) {
                lines.push([new BABYLON.Vector3(-halfSize, -halfSize, z), new BABYLON.Vector3(halfSize, -halfSize, z)]);
                lines.push([new BABYLON.Vector3(-halfSize, halfSize, z), new BABYLON.Vector3(halfSize, halfSize, z)]);
            }
            
            const grid = BABYLON.MeshBuilder.CreateLineSystem("grid", {lines: lines}, gameState.scene);
            grid.color = new BABYLON.Color3(0.5, 0.5, 0.5);
            grid.alpha = 0.5;

            const secondGridSize = 20;
            const secondHalfSize = (secondGridSize * gameState.gridSize) / 2;
            const offsetY = -(gameState.targetCubeSize * gameState.gridSize) / 2 - gameState.gridSize;

            const secondGridLines = [];
            for (let x = -secondHalfSize; x <= secondHalfSize; x += gameState.gridSize) {
                secondGridLines.push([new BABYLON.Vector3(x, offsetY, -secondHalfSize), new BABYLON.Vector3(x, offsetY, secondHalfSize)]);
            }
            
            for (let z = -secondHalfSize; z <= secondHalfSize; z += gameState.gridSize) {
                secondGridLines.push([new BABYLON.Vector3(-secondHalfSize, offsetY, z), new BABYLON.Vector3(secondHalfSize, offsetY, z)]);
            }

            const secondGrid = BABYLON.MeshBuilder.CreateLineSystem("secondGrid", {lines: secondGridLines}, gameState.scene);
            secondGrid.color = new BABYLON.Color3(0.8, 0.2, 0.2);
            secondGrid.alpha = 0.2;
        }

        function createPieces(blockPositions, pieceIndex, levelColorMode, textureUrl = null, materialType = 'normal') {
            const piece = {
                blocks: [],
                root: new BABYLON.TransformNode(`pieceRoot${pieceIndex}`, gameState.scene),
                position: new BABYLON.Vector3(0, 0, 0),
                rotation: 0,
                originalPositions: [],
                assembledPosition: new BABYLON.Vector3(0, 0, 0),
                assembledRotation: 0,
                index: pieceIndex 
            };
            
            const center = new BABYLON.Vector3(0, 0, 0);
            blockPositions.forEach(pos => center.addInPlace(pos));
            center.scaleInPlace(1.0 / blockPositions.length);
            
            // Aleatorizar efectos para esta pieza
            const useTransparency = Math.random() > 0.7; // 30% de probabilidad
            const useGradient = Math.random() > 0.6; // 40% de probabilidad
            const useReflection = Math.random() > 0.5; // 50% de probabilidad
            const randomEffect = Math.random();
            
            let normalMaterial;
            let darkerMaterial;

            if (materialType !== 'normal' || randomEffect > 0.7) {
                normalMaterial = new BABYLON.PBRMaterial(`normalPBRMat${pieceIndex}`, gameState.scene);
                darkerMaterial = new BABYLON.PBRMaterial(`darkerPBRMat${pieceIndex}`, gameState.scene);
                
                [normalMaterial, darkerMaterial].forEach(mat => {
                    mat.environmentTexture = gameState.scene.environmentTexture;
                    mat.useAmbientOcclusionFromMetallicTextureRed = true;
                    mat.useRoughnessFromMetallicTextureGreen = true;
                    mat.useMetallnessFromMetallicTextureBlue = true;
                    mat.directIntensity = 1.5;
                    
                    // Aplicar efectos aleatorios
                    if (useTransparency) {
                        mat.alpha = 0.5 + Math.random() * 0.5; // Transparencia entre 0.5 y 1
                        mat.transparencyMode = BABYLON.PBRMaterial.PBRTRANSPARENCYMODE_ALPHABLEND;
                    }
                    
                    if (useReflection) {
                        mat.metallic = 0.5 + Math.random() * 0.5; // 0.5 a 1.0
                        mat.roughness = 0.1 + Math.random() * 0.4; // 0.1 a 0.5
                    }
                });

                // Combinar con efectos espec√≠ficos del nivel
                switch(materialType) {
                    case 'metallic':
                        normalMaterial.albedoColor = new BABYLON.Color3(0.9, 0.8, 0.4);
                        normalMaterial.metallic = Math.max(0.7, normalMaterial.metallic || 0);
                        normalMaterial.roughness = Math.min(0.4, normalMaterial.roughness || 1);
                        break;
                    case 'glassy':
                        normalMaterial.albedoColor = new BABYLON.Color3(0.8, 0.9, 1.0);
                        normalMaterial.metallic = 0.0;
                        normalMaterial.roughness = 0.0;
                        normalMaterial.alpha = normalMaterial.alpha || 0.7;
                        normalMaterial.linkRefractionWithTransparency = true;
                        normalMaterial.indexOfRefraction = 0.98;
                        normalMaterial.transparencyMode = BABYLON.PBRMaterial.PBRTRANSPARENCYMODE_ALPHABLEND;
                        break;
                    case 'brightMetallic':
                        normalMaterial.albedoColor = new BABYLON.Color3(0.95, 0.95, 0.99);
                        normalMaterial.metallic = 1.0;
                        normalMaterial.roughness = 0.1;
                        break;
                    case 'texturedMetallic':
                        if (textureUrl) {
                            normalMaterial.albedoTexture = new BABYLON.Texture(textureUrl, gameState.scene);
                            normalMaterial.metallicTexture = normalMaterial.albedoTexture;
                        } else {
                            normalMaterial.albedoColor = new BABYLON.Color3(0.7, 0.4, 0.2);
                        }
                        normalMaterial.metallic = 0.9;
                        normalMaterial.roughness = 0.4;
                        break;
                }
            } else {
                // Material est√°ndar con efectos aleatorios
                if (textureUrl) {
                    normalMaterial = new BABYLON.StandardMaterial(`normalMat${pieceIndex}`, gameState.scene);
                    normalMaterial.diffuseTexture = new BABYLON.Texture(textureUrl, gameState.scene);
                    normalMaterial.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                    normalMaterial.emissiveColor = new BABYLON.Color3(0, 0, 0);
                    normalMaterial.diffuseTexture.uScale = 2;
                    normalMaterial.diffuseTexture.vScale = 2;

                    darkerMaterial = new BABYLON.StandardMaterial(`darkerMat${pieceIndex}`, gameState.scene);
                    darkerMaterial.diffuseTexture = new BABYLON.Texture(textureUrl, gameState.scene);
                    darkerMaterial.diffuseColor = new BABYLON.Color3(0.6, 0.6, 0.6);
                    darkerMaterial.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                    darkerMaterial.emissiveColor = new BABYLON.Color3(0, 0, 0);
                    darkerMaterial.diffuseTexture.uScale = 2;
                    darkerMaterial.diffuseTexture.vScale = 2;
                } else {
                    let pieceColor;
                    const randomComponent = 0.5 + Math.random() * 0.5;

                    switch (levelColorMode) {
                        case 'grayscale':
                            const grayValue = 0.3 + Math.random() * 0.5; 
                            pieceColor = new BABYLON.Color3(grayValue, grayValue, grayValue);
                            break;
                        case 'yellow':
                            pieceColor = new BABYLON.Color3(1, randomComponent, 0); 
                            break;
                        case 'red':
                            pieceColor = new BABYLON.Color3(randomComponent, 0, 0); 
                            break;
                        case 'blue':
                            pieceColor = new BABYLON.Color3(0, 0, randomComponent); 
                            break;
                        case 'green':
                            pieceColor = new BABYLON.Color3(0, randomComponent, 0); 
                            break;
                        case 'purple':
                            const purpleValue = 0.5 + Math.random() * 0.5;
                            pieceColor = new BABYLON.Color3(purpleValue, 0, purpleValue); 
                            break;
                        case 'orange':
                            const orangeGreenValue = 0.2 + Math.random() * 0.4;
                            pieceColor = new BABYLON.Color3(1, orangeGreenValue, 0); 
                            break;
                        case 'normal': 
                        default:
                            pieceColor = COLORS[pieceIndex % COLORS.length]; 
                            break;
                    }

                    // Aplicar degradado de color si est√° activado
                    if (useGradient) {
                        const gradientFactor = 0.3 + Math.random() * 0.4; // 0.3 a 0.7
                        const gradientColor = pieceColor.scale(gradientFactor);
                        
                        normalMaterial = new BABYLON.StandardMaterial(`normalMat${pieceIndex}`, gameState.scene);
                        normalMaterial.diffuseColor = pieceColor;
                        normalMaterial.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                        normalMaterial.emissiveColor = new BABYLON.Color3(0, 0, 0);
                        
                        // Aplicar transparencia si est√° activada
                        if (useTransparency) {
                            normalMaterial.alpha = 0.6 + Math.random() * 0.4; // 0.6 a 1.0
                            normalMaterial.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND;
                        }
                        
                        // Aplicar reflexi√≥n si est√° activada
                        if (useReflection) {
                            normalMaterial.reflectionTexture = gameState.scene.environmentTexture;
                            normalMaterial.reflectionFresnel = true;
                            normalMaterial.reflectionFresnelParameters = new BABYLON.FresnelParameters();
                            normalMaterial.reflectionFresnelParameters.bias = 0.1;
                            normalMaterial.reflectionFresnelParameters.power = 2;
                        }

                        darkerMaterial = new BABYLON.StandardMaterial(`darkerMat${pieceIndex}`, gameState.scene);
                        darkerMaterial.diffuseColor = gradientColor;
                        darkerMaterial.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                        darkerMaterial.emissiveColor = new BABYLON.Color3(0, 0, 0);
                        
                        if (useTransparency) {
                            darkerMaterial.alpha = normalMaterial.alpha * 0.8;
                            darkerMaterial.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND;
                        }
                        
                        if (useReflection) {
                            darkerMaterial.reflectionTexture = gameState.scene.environmentTexture;
                            darkerMaterial.reflectionFresnel = true;
                            darkerMaterial.reflectionFresnelParameters = new BABYLON.FresnelParameters();
                            darkerMaterial.reflectionFresnelParameters.bias = 0.2;
                            darkerMaterial.reflectionFresnelParameters.power = 1.5;
                        }
                    } else {
                        normalMaterial = new BABYLON.StandardMaterial(`normalMat${pieceIndex}`, gameState.scene);
                        normalMaterial.diffuseColor = pieceColor;
                        normalMaterial.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                        normalMaterial.emissiveColor = new BABYLON.Color3(0, 0, 0);

                        const darkerColor = pieceColor.scale(0.6);
                        darkerMaterial = new BABYLON.StandardMaterial(`darkerMat${pieceIndex}`, gameState.scene);
                        darkerMaterial.diffuseColor = darkerColor;
                        darkerMaterial.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                        darkerMaterial.emissiveColor = new BABYLON.Color3(0, 0, 0);
                        
                        // Aplicar transparencia si est√° activada
                        if (useTransparency) {
                            normalMaterial.alpha = 0.6 + Math.random() * 0.4; // 0.6 a 1.0
                            normalMaterial.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND;
                            darkerMaterial.alpha = normalMaterial.alpha * 0.8;
                            darkerMaterial.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND;
                        }
                        
                        // Aplicar reflexi√≥n si est√° activada
                        if (useReflection) {
                            normalMaterial.reflectionTexture = gameState.scene.environmentTexture;
                            normalMaterial.reflectionFresnel = true;
                            normalMaterial.reflectionFresnelParameters = new BABYLON.FresnelParameters();
                            normalMaterial.reflectionFresnelParameters.bias = 0.1;
                            normalMaterial.reflectionFresnelParameters.power = 2;
                            darkerMaterial.reflectionTexture = gameState.scene.environmentTexture;
                            darkerMaterial.reflectionFresnel = true;
                            darkerMaterial.reflectionFresnelParameters = new BABYLON.FresnelParameters();
                            darkerMaterial.reflectionFresnelParameters.bias = 0.2;
                            darkerMaterial.reflectionFresnelParameters.power = 1.5;
                        }
                    }
                }
            }
            
            // Define FaceUV if a specific texture is used for it
            let boxOptions = {size: 0.9 * gameState.gridSize};
            if (textureUrl === "https://raw.githubusercontent.com/ravendano014/cubetris/refs/heads/main/cube.jpeg") {
                var columns = 12;
                var rows = 2;
                var faceUV = new Array(6);
                for (var i = 0; i < 6; i++) {
                    faceUV[i] = new BABYLON.Vector4(i / columns, 0, (i + 1) / columns, 1 / rows);
                }
                boxOptions.faceUV = faceUV;
                boxOptions.wrap = true;
            }

            const pieceAssembledGlobalPosition = new BABYLON.Vector3(
                center.x * gameState.gridSize,
                center.y * gameState.gridSize,
                center.z * gameState.gridSize
            );

            blockPositions.forEach((pos, index) => {
                let block;
                if (gameState.currentLevel % 4 === 0) {
                    // Crear esferas para el nivel 4
                    block = BABYLON.MeshBuilder.CreateSphere(
                        `block${pieceIndex}_${index}`, 
                        { 
                            diameter: 0.9 * gameState.gridSize,
                            segments: 16
                        }, 
                        gameState.scene
                    );
                } else {
                    // Crear cubos para otros niveles
                    block = BABYLON.MeshBuilder.CreateBox(
                        `block${pieceIndex}_${index}`, 
                        boxOptions, 
                        gameState.scene
                    );
                }
                block.parent = piece.root;
                const relativePos = pos.subtract(center);
                block.position = relativePos.clone();
                piece.originalPositions.push(relativePos.clone());
                
                const absoluteBlockX = pos.x;
                const absoluteBlockY = pos.y;
                const absoluteBlockZ = pos.z;

                const halfTargetSize = (gameState.targetCubeSize - 1) / 2;
                let isOuterBlock = false;
                if (Math.abs(absoluteBlockX) === halfTargetSize || Math.abs(absoluteBlockY) === halfTargetSize || Math.abs(absoluteBlockZ) === halfTargetSize) {
                    isOuterBlock = true;
                }
                
                block.material = isOuterBlock ? darkerMaterial : normalMaterial;
                block.isPickable = true;
                block.pieceIndex = pieceIndex;
                piece.blocks.push(block);
            });

            piece.assembledPosition = pieceAssembledGlobalPosition;
            gameState.pieces.push(piece);
            return piece;
        }

        function createPiecesForLevelInternal(level, levelColorMode, textureToUse) {
            let numPieces;
            if (level === 14) {
                numPieces = 8;
            } else if (level < 14) {
                numPieces = 4 + Math.floor(level / 2);
                if (numPieces > 10) numPieces = 10;
            } else {
                numPieces = 8 + Math.floor((level - 14) / 2);
                if (numPieces > 12) numPieces = 12;
            }
            
            let materialEffect = 'normal';
            const effectTypes = ['metallic', 'glassy', 'brightMetallic', 'texturedMetallic'];
            
            if (level % 5 === 0 && level > 1) {
                const effectIndex = (Math.floor((level / 2) - 1) % effectTypes.length);
                materialEffect = effectTypes[effectIndex];
            }
            
            if (level === 3) {
                materialEffect = 'normal';
                textureToUse = "https://raw.githubusercontent.com/ravendano014/cubetris/refs/heads/main/cube.jpeg";
            }
            
            const allBlocks = [];
            const halfSize = (gameState.targetCubeSize - 1) / 2;
            
            for (let x = -halfSize; x <= halfSize; x++) {
                for (let y = -halfSize; y <= halfSize; y++) {
                    for (let z = -halfSize; z <= halfSize; z++) {
                        allBlocks.push(new BABYLON.Vector3(x, y, z));
                    }
                }
            }
            
            let blocksPerPiece = Math.floor(allBlocks.length / numPieces);
            if (level > 14) {
                const minBlocks = Math.max(3, Math.floor(blocksPerPiece * 0.7));
                const maxBlocks = Math.min(allBlocks.length, Math.ceil(blocksPerPiece * 1.3));
                blocksPerPiece = Math.floor(Math.random() * (maxBlocks - minBlocks + 1)) + minBlocks;
            }

            for (let i = 0; i < numPieces; i++) {
                const pieceBlocks = [];
                const blocksToTake = (i === numPieces - 1) ? allBlocks.length : blocksPerPiece;
                
                if (allBlocks.length > 0) {
                    const startIndex = Math.floor(Math.random() * allBlocks.length);
                    pieceBlocks.push(allBlocks[startIndex]);
                    allBlocks.splice(startIndex, 1);
                    
                    for (let j = 1; j < blocksToTake && allBlocks.length > 0; j++) {
                        let addedBlock = false;
                        
                        for (let k = 0; k < allBlocks.length && !addedBlock; k++) {
                            const testBlock = allBlocks[k];
                            
                            for (let l = 0; l < pieceBlocks.length; l++) {
                                if (areBlocksAdjacent(testBlock, pieceBlocks[l])) {
                                    pieceBlocks.push(testBlock);
                                    allBlocks.splice(k, 1);
                                    addedBlock = true;
                                    break;
                                }
                            }
                        }
                        
                        if (!addedBlock && allBlocks.length > 0) {
                            const randomIndex = Math.floor(Math.random() * allBlocks.length);
                            pieceBlocks.push(allBlocks[randomIndex]);
                            allBlocks.splice(randomIndex, 1);
                        }
                    }
                }
                
                createPieces(pieceBlocks, i, levelColorMode, textureToUse, materialEffect);
            }
            
            gameState.totalBlocks = gameState.targetCubeSize * gameState.targetCubeSize * gameState.targetCubeSize;
            gameState.correctBlocks = 0;
            updateProgressBar();
        }

        function areBlocksAdjacent(block1, block2) {
            const dx = Math.abs(block1.x - block2.x);
            const dy = Math.abs(block1.y - block2.y);
            const dz = Math.abs(block1.z - block2.z);
            
            return (dx === 1 && dy === 0 && dz === 0) ||
                   (dx === 0 && dy === 1 && dz === 0) ||
                   (dx === 0 && dy === 0 && dz === 1);
        }

        function assemblePieces() {
            gameState.pieces.forEach(piece => {
                piece.position = piece.assembledPosition.clone();
                piece.root.position = piece.assembledPosition.clone();
                piece.rotation = piece.assembledRotation;
                piece.root.rotation.y = piece.assembledRotation;
                updateBlockPositions(piece);
            });
            gameState.isScattered = false;
        }

        function captureReferenceImage() {
            const gameInfo = document.getElementById('gameInfo');
            const controls = document.getElementById('controls');
            const levelComplete = document.getElementById('levelComplete');
            const errorMsg = document.getElementById('errorMsg');
            const onScreenControls = document.getElementById('onScreenControls');
            const rightPanel = document.getElementById('rightPanel');

            if (gameInfo) gameInfo.style.display = 'none';
            if (controls) controls.style.display = 'none';
            if (levelComplete) levelComplete.style.display = 'none';
            if (errorMsg) errorMsg.style.display = 'none';
            if (onScreenControls) onScreenControls.style.display = 'none';
            if (rightPanel) rightPanel.style.display = 'none';

            setTimeout(() => {
                BABYLON.ScreenshotTools.CreateScreenshot(gameState.engine, gameState.camera, { width: 512, height: 512, precision: 1 }, (data) => {
                    const referenceImage = document.getElementById('referenceImage');
                    const referenceImageContainer = document.getElementById('referenceImageContainer');
                    referenceImage.src = data;
                    referenceImageContainer.style.display = 'block';

                    if (gameInfo) gameInfo.style.display = 'block';
                    if (controls) controls.style.display = 'block';
                    if (onScreenControls) onScreenControls.style.display = 'grid';
                    if (rightPanel) rightPanel.style.display = 'flex';

                    gameState.referenceImageTakenForCurrentAssembly = true;
                });
            }, 50);
        }

        function scatterPieces() {
            if (gameState.isScattered || gameState.isAnimating) return;
            
            playSound('scatter');
            
            saveMoveToHistory();
            
            const minDistance = gameState.targetCubeSize * gameState.gridSize * 1.5;
            const maxDistance = gameState.targetCubeSize * gameState.gridSize * 2.5;
            
            const directions = [...SCATTER_DIRECTIONS];
            const usedDirections = new Set();
            
            gameState.pieces.forEach((piece, index) => {
                let direction;
                let attempts = 0;
                const maxAttempts = 20;
                
                do {
                    const dirIndex = Math.floor(Math.random() * directions.length);
                    direction = directions[dirIndex];
                    attempts++;
                    
                    if (attempts >= maxAttempts) {
                        usedDirections.clear();
                        break;
                    }
                } while (usedDirections.has(direction.toString()) && attempts < maxAttempts);
                
                usedDirections.add(direction.toString());
                
                const distanceMultiplier = Math.floor(minDistance/gameState.gridSize) + 
                                         Math.floor(Math.random() * ((maxDistance-minDistance)/gameState.gridSize));
                const distance = distanceMultiplier * gameState.gridSize;
                
                const newPosition = new BABYLON.Vector3(
                    direction.x * distance,
                    direction.y * distance,
                    direction.z * distance
                );
                
                piece.position = newPosition;
                piece.root.position = piece.position.clone();
                
                piece.rotation = Math.floor(Math.random() * 4) * Math.PI / 2;
                piece.root.rotation.y = piece.rotation;
                
                updateBlockPositions(piece);
            });
            
            gameState.isScattered = true;
            gameState.correctBlocks = 0;
            updateProgressBar();
        }

        function updateBlockPositions(piece) {
            piece.blocks.forEach((block, index) => {
                const originalPos = piece.originalPositions[index];
                const rotatedPos = new BABYLON.Vector3(
                    originalPos.z * Math.sin(piece.rotation) + originalPos.x * Math.cos(piece.rotation),
                    originalPos.y,
                    originalPos.z * Math.cos(piece.rotation) - originalPos.x * Math.sin(piece.rotation)
                );
                block.position = rotatedPos;
            });
        }

        function selectPiece(index, isDoubleClick = false) {
            if (gameState.isAnimating || index < 0 || index >= gameState.pieces.length) return;
            
            playSound('select');
            
            if (gameState.pieces[gameState.selectedPieceIndex]) {
                gameState.pieces[gameState.selectedPieceIndex].blocks.forEach(block => {
                    block.renderOutline = false;
                    block.outlineColor = BABYLON.Color3.Black();
                    block.outlineWidth = 0;
                    block.material.emissiveColor = new BABYLON.Color3(0, 0, 0);
                });
            }

            if (index === gameState.selectedPieceIndex && isDoubleClick) {
                gameState.isFineTuneMode = !gameState.isFineTuneMode;
            } else if (index !== gameState.selectedPieceIndex) {
                gameState.isFineTuneMode = false;
            }

            gameState.selectedPieceIndex = index;
            const selectedPiece = gameState.pieces[gameState.selectedPieceIndex];
            
            const emissiveColor = gameState.isFineTuneMode ? FINE_TUNE_EMISSIVE_COLOR : NORMAL_EMISSIVE_COLOR;
            const outlineColor = gameState.isFineTuneMode ? new BABYLON.Color3(1, 1, 0) : new BABYLON.Color3(0, 1, 1);
            const outlineWidth = gameState.isFineTuneMode ? 0.02 : 0.01;

            selectedPiece.blocks.forEach(block => {
                block.material.emissiveColor = emissiveColor;
                block.renderOutline = true;
                block.outlineColor = outlineColor;
                block.outlineWidth = outlineWidth;
            });

            document.getElementById('fineTuneStatus').textContent = gameState.isFineTuneMode ? 'ACTIVATED' : 'DEACTIVATED';
            
            if (gameState.isScattered) {
                const targetPosition = selectedPiece.position.clone();
                const currentTarget = gameState.camera.target;
                const newTarget = BABYLON.Vector3.Lerp(currentTarget, targetPosition, 0.2);
                gameState.camera.setTarget(newTarget);
            }
        }

        function toggleFineTuneMode() {
            if (gameState.pieces.length === 0) return;

            playSound('click');
            
            gameState.isFineTuneMode = !gameState.isFineTuneMode;
            const selectedPiece = gameState.pieces[gameState.selectedPieceIndex];
            if (selectedPiece) {
                const emissiveColor = gameState.isFineTuneMode ? FINE_TUNE_EMISSIVE_COLOR : NORMAL_EMISSIVE_COLOR;
                const outlineColor = gameState.isFineTuneMode ? new BABYLON.Color3(1, 1, 0) : new BABYLON.Color3(0, 1, 1);
                const outlineWidth = gameState.isFineTuneMode ? 0.02 : 0.01;
                selectedPiece.blocks.forEach(block => {
                    block.material.emissiveColor = emissiveColor;
                    block.renderOutline = true;
                    block.outlineColor = outlineColor;
                    block.outlineWidth = outlineWidth;
                });
            }
            document.getElementById('fineTuneStatus').textContent = gameState.isFineTuneMode ? 'ACTIVATED' : 'DEACTIVATED';
        }

        function moveSelectedPiece(direction) {
            if (gameState.isAnimating || !gameState.isScattered) return;
            
            playSound('move');
            
            saveMoveToHistory();
            
            const piece = gameState.pieces[gameState.selectedPieceIndex];
            const newPosition = piece.position.clone();
            const halfSize = (gameState.targetCubeSize * gameState.gridSize) / 2;
            
            const displacement = gameState.isFineTuneMode ? gameState.gridSize / 16 : gameState.gridSize / 2;

            switch (direction) {
                case 'up': 
                    newPosition.y += displacement;
                    if (newPosition.y > halfSize) return;
                    break;
                case 'down': 
                    newPosition.y -= displacement;
                    if (newPosition.y < -halfSize) return;
                    break;
                case 'left': 
                    newPosition.x -= displacement;
                    if (newPosition.x < -halfSize) return;
                    break;
                case 'right': 
                    newPosition.x += displacement;
                    if (newPosition.x > halfSize) return;
                    break;
                case 'forward': 
                    newPosition.z += displacement;
                    if (newPosition.z > halfSize) return;
                    break;
                case 'backward': 
                    newPosition.z -= displacement;
                    if (newPosition.z < -halfSize) return;
                    break;
            }
            
            if (checkCollision(piece, newPosition)) {
                showError("Movement not allowed! There is a collision.");
                playSound('error');
                return;
            }
            
            piece.position = newPosition;
            animatePieceToPosition(piece);
            
            checkCorrectBlocks();
        }

        function checkCollision(piece, newPosition) {
            const pieceBlocksPositions = new Set();
            
            piece.blocks.forEach(block => {
                const globalPos = new BABYLON.Vector3(
                    newPosition.x + block.position.x,
                    newPosition.y + block.position.y,
                    newPosition.z + block.position.z
                );
                const precisionFactor = gameState.gridSize / 4;
                const posKey = `${Math.round(globalPos.x / precisionFactor) * precisionFactor}_${Math.round(globalPos.y / precisionFactor) * precisionFactor}_${Math.round(globalPos.z / precisionFactor) * precisionFactor}`;
                pieceBlocksPositions.add(posKey);
            });
            
            for (let i = 0; i < gameState.pieces.length; i++) {
                if (i === gameState.selectedPieceIndex) continue;
                
                const otherPiece = gameState.pieces[i];
                for (let j = 0; j < otherPiece.blocks.length; j++) {
                    const otherBlock = otherPiece.blocks[j];
                    const otherGlobalPos = otherBlock.getAbsolutePosition();
                    const precisionFactor = gameState.gridSize / 4;
                    const otherPosKey = `${Math.round(otherGlobalPos.x / precisionFactor) * precisionFactor}_${Math.round(otherGlobalPos.y / precisionFactor) * precisionFactor}_${Math.round(otherGlobalPos.z / precisionFactor) * precisionFactor}`;
                    
                    if (pieceBlocksPositions.has(otherPosKey)) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        function rotateSelectedPiece() {
            if (gameState.isAnimating || !gameState.isScattered) return;
            
            playSound('rotate');
            
            saveMoveToHistory();
            
            const piece = gameState.pieces[gameState.selectedPieceIndex];
            const oldRotation = piece.rotation;
            
            piece.rotation += Math.PI / 2;
            if (piece.rotation >= Math.PI * 2) piece.rotation = 0;
            
            updateBlockPositions(piece);
            
            if (checkCollision(piece, piece.position)) {
                piece.rotation = oldRotation;
                updateBlockPositions(piece);
                showError("Rotation not allowed! There is a collision.");
                playSound('error');
                return;
            }
            
            animateRotation(piece, oldRotation);
            
            checkCorrectBlocks();
        }

        function animatePieceToPosition(piece, duration = 200, onComplete = null) {
            if (gameState.animationFrame) {
                cancelAnimationFrame(gameState.animationFrame);
            }
            
            const startTime = Date.now();
            const startPosition = piece.root.position.clone();
            const endPosition = piece.position.clone();
            
            const animate = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                piece.root.position = BABYLON.Vector3.Lerp(
                    startPosition,
                    endPosition,
                    progress
                );
                
                if (progress < 1) {
                    gameState.animationFrame = requestAnimationFrame(animate);
                } else {
                    gameState.animationFrame = null;
                    if (onComplete) onComplete();
                }
            };
            
            animate();
        }

        function animateRotation(piece, startRotation, duration = 200, onComplete = null) {
            if (gameState.animationFrame) {
                cancelAnimationFrame(gameState.animationFrame);
            }
            
            const startTime = Date.now();
            
            const animate = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                piece.root.rotation.y = startRotation + (piece.rotation - startRotation) * progress;
                
                if (progress < 1) {
                    gameState.animationFrame = requestAnimationFrame(animate);
                } else {
                    gameState.animationFrame = null;
                    if (onComplete) onComplete();
                }
            };
            
            animate();
        }

        function solvePuzzle() {
            if (gameState.isAnimating || !gameState.isScattered) {
                showError("Cannot solve now");
                playSound('error');
                return;
            }
            
            playSound('click');
            
            gameState.isAnimating = true;
            
            let currentPieceIndex = 0;
            const solveNextPiece = () => {
                if (currentPieceIndex >= gameState.pieces.length) {
                    gameState.isAnimating = false;
                    checkPuzzleComplete();
                    return;
                }
                
                const piece = gameState.pieces[currentPieceIndex];
                selectPiece(currentPieceIndex);
                
                const moveDuration = 1000;
                const rotateDuration = 800;
                
                const rotationSteps = Math.round((piece.assembledRotation - piece.rotation) / (Math.PI/2));
                let rotationCount = 0;
                
                const rotateStep = () => {
                    if (rotationCount < Math.abs(rotationSteps)) {
                        piece.rotation += (Math.PI/2) * Math.sign(rotationSteps);
                        if (piece.rotation >= Math.PI * 2) piece.rotation = 0;
                        if (piece.rotation < 0) piece.rotation += Math.PI * 2;
                        
                        updateBlockPositions(piece);
                        animateRotation(piece, piece.rotation - (Math.PI/2) * Math.sign(rotationSteps), rotateDuration, () => {
                            rotationCount++;
                            setTimeout(rotateStep, 200);
                        });
                    } else {
                        const startPosition = piece.position.clone();
                        const endPosition = piece.assembledPosition.clone();
                        
                        piece.position = endPosition;
                        animatePieceToPosition(piece, moveDuration, () => {
                            setTimeout(() => {
                                currentPieceIndex++;
                                solveNextPiece();
                            }, 500);
                        });
                    }
                };
                
                if (rotationSteps !== 0) {
                    rotateStep();
                } else {
                    const startPosition = piece.position.clone();
                    const endPosition = piece.assembledPosition.clone();
                    
                    piece.position = endPosition;
                    animatePieceToPosition(piece, moveDuration, () => {
                        setTimeout(() => {
                            currentPieceIndex++;
                            solveNextPiece();
                        }, 500);
                    });
                }
            };
            
            solveNextPiece();
        }

        function checkPuzzleComplete() {
            if (!gameState.isScattered) return;

            const targetSize = gameState.targetCubeSize;
            const halfSize = (targetSize * gameState.gridSize) / 2;
            const boundaryTolerance = 0.25 * gameState.gridSize;

            const outOfBoundsPieces = new Set();
            const overlappingPieces = new Set();
            
            const occupiedGrid = new Map();

            for (let i = 0; i < targetSize; i++) {
                for (let j = 0; j < targetSize; j++) {
                    for (let k = 0; k < targetSize; k++) {
                        const gridX = (i - (targetSize - 1) / 2) * gameState.gridSize;
                        const gridY = (j - (targetSize - 1) / 2) * gameState.gridSize;
                        const gridZ = (k - (targetSize - 1) / 2) * gameState.gridSize;
                        const posKey = `${gridX}_${gridY}_${gridZ}`;
                        occupiedGrid.set(posKey, null);
                    }
                }
            }
            
            const expectedTotalBlocks = targetSize * targetSize * targetSize;
            let currentBlockCount = 0;
            let foundError = false;

            for (const piece of gameState.pieces) {
                for (const block of piece.blocks) {
                    const rotatedBlockLocalPos = block.position;

                    const actualBlockGlobalX = piece.position.x + rotatedBlockLocalPos.x;
                    const actualBlockGlobalY = piece.position.y + rotatedBlockLocalPos.y;
                    const actualBlockGlobalZ = piece.position.z + rotatedBlockLocalPos.z;

                    const precisionFactor = gameState.gridSize / 4;
                    const snappedX = Math.round(actualBlockGlobalX / precisionFactor) * precisionFactor;
                    const snappedY = Math.round(actualBlockGlobalY / precisionFactor) * precisionFactor;
                    const snappedZ = Math.round(actualBlockGlobalZ / precisionFactor) * precisionFactor;
                    
                    if (snappedX < -halfSize - boundaryTolerance || snappedX > halfSize + boundaryTolerance ||
                        snappedY < -halfSize - boundaryTolerance || snappedY > halfSize + boundaryTolerance ||
                        snappedZ < -halfSize - boundaryTolerance || snappedZ > halfSize + boundaryTolerance) {
                        
                        outOfBoundsPieces.add(piece);
                        foundError = true;
                        continue;
                    }
                    
                    const posKey = `${snappedX}_${snappedY}_${snappedZ}`;

                    if (occupiedGrid.has(posKey) && occupiedGrid.get(posKey) !== null) {
                        const existingBlock = occupiedGrid.get(posKey);
                        const existingPiece = gameState.pieces[existingBlock.pieceIndex];
                        
                        overlappingPieces.add(piece);
                        overlappingPieces.add(existingPiece);
                        foundError = true;
                        continue;
                    } else if (!occupiedGrid.has(posKey)) {
                        outOfBoundsPieces.add(piece);
                        foundError = true;
                        continue;
                    }
                    else {
                        occupiedGrid.set(posKey, block);
                        currentBlockCount++;
                    }
                }
            }

            if (outOfBoundsPieces.size > 0) {
                showError("One or more pieces are outside the grid cube, or rotate the piece inside the cube and retry!");
                outOfBoundsPieces.forEach(p => highlightPiece(p, new BABYLON.Color3(1, 0, 0)));
                playSound('error');
            } else if (overlappingPieces.size > 0) {
                showError("There are overlapping blocks!");
                overlappingPieces.forEach(p => highlightPiece(p, new BABYLON.Color3(1, 0, 0)));
                playSound('error');
            } else if (currentBlockCount !== expectedTotalBlocks) {
                showError("The cube is not correctly assembled. Blocks are missing or misplaced.");
                playSound('error');
            } else {
                levelComplete();
            }
        }

        function checkCorrectBlocks() {
            const targetSize = gameState.targetCubeSize;
            const halfSize = (targetSize * gameState.gridSize) / 2;
            const boundaryTolerance = 0.1 * gameState.gridSize;
            
            let correctCount = 0;
            const occupiedGrid = new Map();

            for (let i = 0; i < targetSize; i++) {
                for (let j = 0; j < targetSize; j++) {
                    for (let k = 0; k < targetSize; k++) {
                        const gridX = (i - (targetSize - 1) / 2) * gameState.gridSize;
                        const gridY = (j - (targetSize - 1) / 2) * gameState.gridSize;
                        const gridZ = (k - (targetSize - 1) / 2) * gameState.gridSize;
                        const posKey = `${gridX}_${gridY}_${gridZ}`;
                        occupiedGrid.set(posKey, false);
                    }
                }
            }

            for (const piece of gameState.pieces) {
                for (const block of piece.blocks) {
                    const rotatedBlockLocalPos = block.position;
                    const actualBlockGlobalX = piece.position.x + rotatedBlockLocalPos.x;
                    const actualBlockGlobalY = piece.position.y + rotatedBlockLocalPos.y;
                    const actualBlockGlobalZ = piece.position.z + rotatedBlockLocalPos.z;
                    
                    const assembledBlockGlobalX = piece.assembledPosition.x + rotatedBlockLocalPos.x;
                    const assembledBlockGlobalY = piece.assembledPosition.y + rotatedBlockLocalPos.y;
                    const assembledBlockGlobalZ = piece.assembledPosition.z + rotatedBlockLocalPos.z;
                    
                    const dx = Math.abs(actualBlockGlobalX - assembledBlockGlobalX);
                    const dy = Math.abs(actualBlockGlobalY - assembledBlockGlobalY);
                    const dz = Math.abs(actualBlockGlobalZ - assembledBlockGlobalZ);
                    
                    if (dx < boundaryTolerance && dy < boundaryTolerance && dz < boundaryTolerance) {
                        const posKey = `${assembledBlockGlobalX}_${assembledBlockGlobalY}_${assembledBlockGlobalZ}`;
                        if (!occupiedGrid.get(posKey)) {
                            occupiedGrid.set(posKey, true);
                            correctCount++;
                            block.material.emissiveColor = CORRECT_POSITION_COLOR;
                            setTimeout(() => {
                                if (piece.index === gameState.selectedPieceIndex) {
                                    block.material.emissiveColor = gameState.isFineTuneMode ? FINE_TUNE_EMISSIVE_COLOR : NORMAL_EMISSIVE_COLOR;
                                } else {
                                    block.material.emissiveColor = new BABYLON.Color3(0, 0, 0);
                                }
                            }, 500);
                        }
                    }
                }
            }
            
            gameState.correctBlocks = correctCount;
            updateProgressBar();
        }
        
        function updateProgressBar() {
            const progress = (gameState.correctBlocks / gameState.totalBlocks) * 100;
            document.getElementById('progressFill').style.width = `${progress}%`;
        }

        function checkProximityAndOverlap() {
            if (!gameState.isScattered) {
                showError("Pieces are not scattered! Use the 'Scatter' button first.");
                playSound('error');
                return;
            }

            const targetSize = gameState.targetCubeSize;
            const halfSize = (targetSize * gameState.gridSize) / 2;
            const proximityThreshold = gameState.gridSize;

            let hasOverlap = false;
            let isTooFar = false;

            const occupiedGrid = new Map();

            for (const piece of gameState.pieces) {
                for (const block of piece.blocks) {
                    const rotatedBlockLocalPos = block.position;

                    const actualBlockGlobalX = piece.position.x + rotatedBlockLocalPos.x;
                    const actualBlockGlobalY = piece.position.y + rotatedBlockLocalPos.y;
                    const actualBlockGlobalZ = piece.position.z + rotatedBlockLocalPos.z;

                    if (actualBlockGlobalX < -halfSize - proximityThreshold || actualBlockGlobalX > halfSize + proximityThreshold ||
                        actualBlockGlobalY < -halfSize - proximityThreshold || actualBlockGlobalY > halfSize + proximityThreshold ||
                        actualBlockGlobalZ < -halfSize - proximityThreshold || actualBlockGlobalZ > halfSize + proximityThreshold) {
                        isTooFar = true;
                        highlightPiece(piece, new BABYLON.Color3(1, 0.5, 0));
                    }

                    const precisionFactor = gameState.gridSize / 4;
                    const gridX = Math.round(actualBlockGlobalX / precisionFactor) * precisionFactor;
                    const gridY = Math.round(actualBlockGlobalY / precisionFactor) * precisionFactor;
                    const gridZ = Math.round(actualBlockGlobalZ / precisionFactor) * precisionFactor;
                    
                    const posKey = `${gridX}_${gridY}_${gridZ}`;

                    if (occupiedGrid.has(posKey) && occupiedGrid.get(posKey) !== null) {
                        hasOverlap = true;
                        highlightPiece(piece, new BABYLON.Color3(1, 0, 0));
                        const existingPiece = gameState.pieces[occupiedGrid.get(posKey).pieceIndex];
                        highlightPiece(existingPiece, new BABYLON.Color3(1, 0, 0));
                    } else {
                        occupiedGrid.set(posKey, block);
                    }
                }
            }

            if (hasOverlap) {
                showError("There are overlapping blocks!");
                playSound('error');
            } else if (isTooFar) {
                showError("One or more pieces are too far from the cube!");
                playSound('error');
            } else {
                levelComplete();
            }
        }

        function levelComplete() {
            playSound('success');
            
            const timeElapsed = Math.floor((Date.now() - gameState.levelStartTime) / 1000);
            const timeBonus = Math.max(0, 300 - timeElapsed);
            const levelScore = 100 + timeBonus + (gameState.currentLevel * 10);
            
            gameState.score += levelScore;
            
            document.getElementById('levelTime').textContent = timeElapsed;
            document.getElementById('levelScore').textContent = levelScore;
            document.getElementById('levelComplete').style.display = 'block';
            
            document.getElementById('scoreDisplay').textContent = `Score: ${gameState.score}`;
            
            clearInterval(gameState.timerInterval);
            
            saveGame();
        }

        function highlightPiece(pieceToHighlight, color, duration = 500) {
            const originalEmissiveColors = pieceToHighlight.blocks.map(b => b.material.emissiveColor.clone());
            pieceToHighlight.blocks.forEach(b => b.material.emissiveColor = color);
            setTimeout(() => {
                pieceToHighlight.blocks.forEach((b, i) => {
                    if (pieceToHighlight.index === gameState.selectedPieceIndex) {
                        b.material.emissiveColor = gameState.isFineTuneMode ? FINE_TUNE_EMISSIVE_COLOR : NORMAL_EMISSIVE_COLOR;
                    } else {
                        b.material.emissiveColor = originalEmissiveColors[i]; 
                    }
                });
            }, duration);
        }

        function showError(message) {
            const errorMsg = document.getElementById('errorMsg');
            errorMsg.textContent = message;
            errorMsg.style.display = 'block';
            
            setTimeout(() => {
                errorMsg.style.display = 'none';
            }, 2000);
        }

        function nextLevel() {
            playSound('click');
            gameState.currentLevel++;
            startLevel(gameState.currentLevel);
        }

        function resetCamera() {
            playSound('click');
            gameState.camera.alpha = -Math.PI / 2;
            gameState.camera.beta = Math.PI / 3;
            gameState.camera.radius = 20;
            gameState.camera.setTarget(BABYLON.Vector3.Zero());
        }

        function resetGame() {
            playSound('click');
            gameState.currentLevel = 1;
            gameState.score = 0;
            document.getElementById('scoreDisplay').textContent = `Score: ${gameState.score}`;
            startLevel(gameState.currentLevel);
        }

        function startLevel(level) {
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
            }
            
            gameState.levelStartTime = Date.now();
            gameState.timerInterval = setInterval(updateTimer, 1000);
            
            while (gameState.scene.meshes.length > 0) {
                gameState.scene.meshes[0].dispose();
            }
            
            gameState.pieces = [];
            gameState.selectedPieceIndex = 0;
            gameState.isScattered = false;
            gameState.isFineTuneMode = false;
            gameState.referenceImageTakenForCurrentAssembly = false;
            gameState.moveHistory = [];

            let levelColorMode = 'normal';
            let textureToUse = null;

            const colorModes = ['normal', 'grayscale', 'black', 'white', 'yellow', 'red', 'blue', 'green', 'purple', 'orange', 'brown'];
            
            if (level <= 15 || (level > 25 && level <= 35) || (level > 45 && level <= 55) || (level > 65 && level <= 75) || (level > 85 && level <= 95) ) {
                levelColorMode = 'normal';
                if (level % 7 === 0){
                    const textureIndex = Math.floor(((level - 1) / 5)) % TEXTURE_URLS.length;
                    textureToUse = TEXTURE_URLS[textureIndex];
                }
            } else {
                if (level <= 2) {
                    levelColorMode = 'normal';
                } else {
                    const effectiveLevel = level - 3; 
                    const modeIndex = (effectiveLevel % (colorModes.length - 1)) + 1; 
                    levelColorMode = colorModes[modeIndex];
                }
            }

            if (level === 1) {
                levelColorMode = 'normal';
                gameState.targetCubeSize = 2;
            } else if (level === 3) {
                levelColorMode = 'normal';
                gameState.targetCubeSize = 3;
                textureToUse = "https://raw.githubusercontent.com/ravendano014/cubetris/refs/heads/main/cube.jpeg";
            } else if (level <= 4) {
                gameState.targetCubeSize = 3;
            } else if (level <= 6) {
                gameState.targetCubeSize = 4;
            } else if (level <= 10) {
                gameState.targetCubeSize = 5;
            } else if (level <= 15) {
                gameState.targetCubeSize = 6;
            } else if (level <= 20) {
                gameState.targetCubeSize = 7;
            } else if (level <= 25) {
                gameState.targetCubeSize = 8;
            } else if (level <= 30) {
                gameState.targetCubeSize = 9;
            } else if (level <= 35) {
                gameState.targetCubeSize = 10;
            } else if (level <= 40) {
                gameState.targetCubeSize = 11;
            } else {
                const sizes = [3, 5, 7, 9, 11];
                gameState.targetCubeSize = sizes[Math.floor(Math.random() * sizes.length)];
            }
            
            document.getElementById('levelDisplay').textContent = gameState.currentLevel;
            document.getElementById('fineTuneStatus').textContent = gameState.isFineTuneMode ? 'ACTIVATED' : 'DEACTIVATED';
            document.getElementById('levelComplete').style.display = 'none';
            document.getElementById('solveBtn').disabled = false;

            const referenceImageContainer = document.getElementById('referenceImageContainer');
            const referenceImage = document.getElementById('referenceImage');
            referenceImage.src = '';
            referenceImageContainer.style.display = 'none';
            
            createTargetCube();
            createGrid();
            createPiecesForLevelInternal(level, levelColorMode, textureToUse);
            assemblePieces();
            captureReferenceImage();
            selectPiece(0);
        }
        
        function updateTimer() {
            const elapsed = Math.floor((Date.now() - gameState.levelStartTime) / 1000);
            document.getElementById('timerDisplay').textContent = `Time: ${elapsed}s`;
        }
        
        function saveMoveToHistory() {
            if (gameState.pieces.length === 0) return;
            
            const state = gameState.pieces.map(piece => ({
                position: piece.position.clone(),
                rotation: piece.rotation,
                index: piece.index
            }));
            
            gameState.moveHistory.push(state);
            
            if (gameState.moveHistory.length > gameState.maxUndoSteps) {
                gameState.moveHistory.shift();
            }
        }
        
        function undoLastMove() {
            if (gameState.isAnimating || gameState.moveHistory.length === 0) {
                playSound('error');
                return;
            }
            
            playSound('click');
            
            const lastState = gameState.moveHistory.pop();
            
            lastState.forEach(pieceState => {
                const piece = gameState.pieces[pieceState.index];
                piece.position = pieceState.position.clone();
                piece.rotation = pieceState.rotation;
                
                piece.root.position = piece.position.clone();
                piece.root.rotation.y = piece.rotation;
                updateBlockPositions(piece);
                
                animatePieceToPosition(piece);
            });
            
            checkCorrectBlocks();
        }
        
        function saveGame() {
            try {
                const saveData = {
                    level: gameState.currentLevel,
                    score: gameState.score,
                    darkTheme: gameState.darkTheme,
                    soundEnabled: gameState.soundEnabled
                };
                localStorage.setItem('cubetrisSave', JSON.stringify(saveData));
            } catch (e) {
                console.error("Failed to save game:", e);
            }
        }
        
        function loadGame() {
            try {
                const saveData = JSON.parse(localStorage.getItem('cubetrisSave'));
                if (saveData) {
                    gameState.currentLevel = saveData.level || 1;
                    gameState.score = saveData.score || 0;
                    gameState.darkTheme = saveData.darkTheme || false;
                    gameState.soundEnabled = saveData.soundEnabled || false;
                    
                    const themeToggle = document.getElementById('themeToggle');
                    if (gameState.darkTheme) {
                        document.body.classList.add('dark-theme');
                        themeToggle.textContent = '‚òÄÔ∏è Theme';
                    } else {
                        document.body.classList.add('light-theme');
                        themeToggle.textContent = 'üåô Theme';
                    }
                    
                    document.getElementById('scoreDisplay').textContent = `Score: ${gameState.score}`;
                }
            } catch (e) {
                console.error("Failed to load game:", e);
            }
        }
        
        function giveHint() {
            if (gameState.isAnimating || !gameState.isScattered) {
                playSound('error');
                return;
            }
            
            playSound('click');
            
            let closestPiece = null;
            let minDistance = Infinity;
            
            for (const piece of gameState.pieces) {
                const distance = BABYLON.Vector3.Distance(piece.position, piece.assembledPosition);
                if (distance < minDistance && distance > 0.1) {
                    minDistance = distance;
                    closestPiece = piece;
                }
            }
            
            if (closestPiece) {
                selectPiece(closestPiece.index);
                
                highlightPiece(closestPiece, new BABYLON.Color3(1, 1, 0), 2000);
                
                const direction = closestPiece.assembledPosition.subtract(closestPiece.position).normalize();
                let directionText = "";
                
                if (Math.abs(direction.x) > Math.abs(direction.y) && Math.abs(direction.x) > Math.abs(direction.z)) {
                    directionText = direction.x > 0 ? "Move RIGHT" : "Move LEFT";
                } else if (Math.abs(direction.y) > Math.abs(direction.z)) {
                    directionText = direction.y > 0 ? "Move UP" : "Move DOWN";
                } else {
                    directionText = direction.z > 0 ? "Move FORWARD" : "Move BACKWARD";
                }
                
                showError(`Hint: Select piece ${closestPiece.index + 1}. ${directionText}`);
            } else {
                showError("All pieces are already in position!");
            }
        }

        function setupControls() {
            const keyMap = {
                'p': 'scatter',
                'w': 'up',
                's': 'down',
                'a': 'right',
                'e': 'backward',
                'd': 'left',
                'q': 'forward',
                'r': 'rotate',
                ' ': 'change',
                'm': 'toggleFineTune',
                'v': 'check',
                'k': 'okForMe',
                'u': 'undo',
                'h': 'hint',
                'c': 'capture'
            };
            
            document.addEventListener('keydown', (e) => {
                const action = keyMap[e.key.toLowerCase()];
                if (!action) return;
                
                e.preventDefault();
                
                if (action === 'scatter') {
                    scatterPieces();
                } else if (action === 'check') {
                    checkPuzzleComplete();
                } else if (action === 'okForMe') {
                    checkProximityAndOverlap();
                } else if (action === 'undo') {
                    undoLastMove();
                } else if (action === 'hint') {
                    giveHint();
                } else if (action === 'capture') {
                    captureReferenceImage();
                } else {
                    switch (action) {
                        case 'up':
                        case 'down':
                        case 'left':
                        case 'right':
                        case 'forward':
                        case 'backward':
                            moveSelectedPiece(action);
                            break;
                        case 'rotate':
                            rotateSelectedPiece();
                            break;
                        case 'change':
                            selectPiece((gameState.selectedPieceIndex + 1) % gameState.pieces.length);
                            break;
                        case 'toggleFineTune':
                            toggleFineTuneMode();
                            break;
                    }
                }
            });
        }

        function setupPointerControls() {
            gameState.canvas.addEventListener("pointerdown", function (evt) {
                if (evt.button !== 0) return; 

                const pickResult = gameState.scene.pick(evt.clientX, evt.clientY);
                const currentTime = Date.now();
                const deltaTime = currentTime - gameState.lastClickTime;

                if (pickResult.hit && pickResult.pickedMesh && pickResult.pickedMesh.pieceIndex !== undefined) {
                    const clickedPieceIndex = pickResult.pickedMesh.pieceIndex;

                    if (deltaTime < gameState.doubleClickThreshold && clickedPieceIndex === gameState.selectedPieceIndex) {
                        selectPiece(clickedPieceIndex, true); 
                    } else if (clickedPieceIndex !== gameState.selectedPieceIndex) {
                        selectPiece(clickedPieceIndex, false); 
                    } else {
                        if (gameState.isFineTuneMode) {
                            selectPiece(clickedPieceIndex, false);
                        }
                    }
                } else {
                    if (gameState.pieces[gameState.selectedPieceIndex]) {
                        gameState.pieces[gameState.selectedPieceIndex].blocks.forEach(block => {
                            block.renderOutline = false;
                            block.outlineColor = BABYLON.Color3.Black();
                            block.outlineWidth = 0;
                            block.material.emissiveColor = new BABYLON.Color3(0, 0, 0);
                        });
                    }
                    gameState.isFineTuneMode = false;
                    document.getElementById('fineTuneStatus').textContent = 'DEACTIVATED';
                }

                gameState.lastClickTime = currentTime;
            });
        }

        function setupUI() {
            document.getElementById('btnScatter').addEventListener('click', scatterPieces);
            document.getElementById('btnCheck').addEventListener('click', checkPuzzleComplete);
            document.getElementById('btnReset').addEventListener('click', resetGame);
            document.getElementById('btnItsOk').addEventListener('click', checkProximityAndOverlap);
            document.getElementById('nextLevelBtn').addEventListener('click', nextLevel);
            document.getElementById('solveBtn').addEventListener('click', solvePuzzle);
            document.getElementById('resetCameraBtn').addEventListener('click', resetCamera);
            document.getElementById('hintBtn').addEventListener('click', giveHint);
            document.getElementById('captureBtn').addEventListener('click', captureReferenceImage);

            document.getElementById('moveUp').addEventListener('click', () => moveSelectedPiece('up'));
            document.getElementById('moveDown').addEventListener('click', () => moveSelectedPiece('down'));
            document.getElementById('moveLeft').addEventListener('click', () => moveSelectedPiece('left'));
            document.getElementById('moveRight').addEventListener('click', () => moveSelectedPiece('right'));
            document.getElementById('moveForward').addEventListener('click', () => moveSelectedPiece('forward'));
            document.getElementById('moveBackward').addEventListener('click', () => moveSelectedPiece('backward'));
            document.getElementById('rotateBtn').addEventListener('click', rotateSelectedPiece);
            document.getElementById('changePieceBtn').addEventListener('click', () => selectPiece((gameState.selectedPieceIndex + 1) % gameState.pieces.length));
            document.getElementById('fineTuneBtn').addEventListener('click', toggleFineTuneMode);
        }

        window.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>
