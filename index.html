<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Cubetris - Enhanced Version</title>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            touch-action: none;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            width: 250px;
            z-index: 10;
            user-select: none;
        }
        #levelComplete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 100;
            width: 300px;
        }
        button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 12px 24px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 8px 4px;
            cursor: pointer;
            border-radius: 8一層;
            transition: background-color 0.3s;
            width: 100%;
        }
        button:hover {
            background-color: #45a049;
        }
        #controls {
            margin-top: 15px;
        }
        .control-btn {
            background-color: #2196F3;
        }
        .control-btn:hover {
            background-color: #0b7dda;
        }
        .align-btn {
            background-color: #FF9800;
            margin: 4px 2px;
            width: calc(33% - 8px);
            display: inline-block;
            padding: 8px 0;
        }
        .align-btn:hover {
            background-color: #F57C00;
        }
        .solve-btn {
            background-color: #9C27B0;
            margin-top: 10px;
        }
        .solve-btn:hover {
            background-color: #7B1FA2;
        }
        #alignControls {
            margin-top: 10px;
            text-align: center;
        }
        h2 {
            margin-top: 0;
            color: #4CAF50;
        }
        #errorMsg {
            position: absolute;
            top: 20px;
            right: 20px;
            transform: none;
            background-color: rgba(255,0,0,0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            display: none;
            text-align: center;
            max-width: 300px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .control-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        .control-row button {
            width: calc(50% - 5px);
            margin: 0;
            padding: 8px;
            font-size: 14px;
        }
        .large-btn {
            width: 100%;
        }
        .scatter-btn {
            background-color: #4CAF50;
        }
        .scatter-btn:hover {
            background-color: #45a049;
        }
        .check-btn {
            background-color: #F44336;
        }
        .check-btn:hover {
            background-color: #D32F2F;
        }
        .reset-btn {
            background-color: #007bff;
        }
        .reset-btn:hover {
            background-color: #0056b3;
        }
        .ok-btn {
            background-color: #FFC107;
        }
        .ok-btn:hover {
            background-color: #e0a800;
        }
        #onScreenControls {
            position: absolute;
            bottom: 120px; /* Increased from 60px to 120px to move it up */
            right: 20px; /* Volver a la posición original */
            z-index: 10;
            display: grid;
            grid-template-columns: repeat(3, 120px);
            grid-template-rows: repeat(3, 120px);
            gap: 10px;
            background-color: rgba(0,0,0,0.6);
            padding: 20px;
            border-radius: 10px;
        }
        .dpad-btn {
            background-color: #333;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 36px;
            border-radius: 8px;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s;
        }
        #changePieceBtn { grid-area: 1 / 1 / 1 / 1; background-color: #17b4b2; font-size: 28px;}
        #changePieceBtn:hover { background-color: #00e5ff; }
        #moveUp { grid-area: 1 / 2 / 2 / 3; }
        #moveDown { grid-area: 3 / 2 / 4 / 3; }
        #moveLeft { grid-area: 2 / 1 / 3 / 2; }
        #moveRight { grid-area: 2 / 3 / 3 / 4; }
        #moveForward { grid-area: 1 / 3 / 2 / 4; font-size: 28px;}
        #moveBackward { grid-area: 3 / 1 / 4 / 2; font-size: 28px;}
        #rotateBtn { grid-area: 2 / 2 / 3 / 3; background-color: #FF9800; font-size: 28px;}
        #rotateBtn:hover { background-color: #F57C00; }
        #fineTuneBtn { grid-area: 3 / 3 / 3 / 3; background-color: #d20f8a; font-size: 28px;}
        #fineTuneBtn:hover { background-color: #ff0090; }
        #progressBar {
            height: 10px;
            background-color: #333;
            border-radius: 5px;
            margin-top: 10px;
            overflow: hidden;
        }
        #progressFill {
            height: 100%;
            background-color: #4CAF50;
            width: 0%;
            transition: width 0.3s;
        }
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            color: white;
            text-align: center;
        }
        #startScreen h1 {
            color: #4CAF50;
            font-size: 3em;
            margin-bottom: 20px;
        }
        #startScreen p {
            max-width: 600px;
            margin-bottom: 30px;
            line-height: 1.6;
        }
        .dark-theme {
            background-color: #121212;
            color: #ffffff;
        }
        .light-theme {
            background-color: #f5f5f5;
            color: #333333;
        }
        /* Nuevo estilo para el panel superior central */
        #topCenterPanel {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 150;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: rgba(0,0,0,0.7);
            padding: 12px 20px;
            border-radius: 8px;
            min-width: 200px;
        }

        #topCenterPanel p {
            margin: 4px 0;
            font-size: 14px;
            text-align: center;
            color: white;
        }

        #topCenterControls {
            display: flex;
            gap: 10px;
            margin-top: 8px;
        }

        #themeToggle, #hintBtn, #reCaptureBtn { /* Add #reCaptureBtn here */
            background-color: #333;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            white-space: nowrap;
        }

        #themeToggle:hover, #hintBtn:hover, #reCaptureBtn:hover { /* Add #reCaptureBtn here */
            background-color: #555;
        }

        /* Ajustar posición de los controles en pantalla */
        #onScreenControls {
            right: 20px; /* Volver a la posición original */
        }
        #hintBtn {
            background-color: #9C27B0;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            width: 100%;
        }
        #hintBtn:hover {
            background-color: #7B1FA2;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
</head>
<body>
    <div id="startScreen">
        <h1>Cubetris</h1>
        <p>Welcome to Cubetris! Your goal is to assemble the scattered pieces back into a complete cube.</p>
        <p>Controls: Use the on-screen buttons or keyboard (WASD for movement, Q/E for forward/backward, R to rotate, Space to change piece, P to scatter, V to check, M for fine-tune mode).</p>
        <button id="startButton" style="padding: 15px 30px; font-size: 1.2em;">Start Game</button>
    </div>
    
    <canvas id="renderCanvas"></canvas>
    <div id="ui">
        <h2>Cubetris</h2>
        <div id="referenceImageContainer" style="display: none; margin-top: 10px; text-align: center;">
            <p style="margin-bottom: 5px; font-weight: bold;">Reference:</p>
            <img id="referenceImage" src="" alt="Assembled Cube Reference" style="width: 100%; border: 1px solid #555; border-radius: 5px;">
        </div>
        <div id="gameInfo">
            <p>Level: <span id="levelDisplay">1</span></p>
            <p>Fine Tune: <span id="fineTuneStatus">DEACTIVATED</span></p>
            <div id="progressBar">
                <div id="progressFill"></div>
            </div>
        </div>
        
        <div id="controls">
            <button class="control-btn scatter-btn" id="btnScatter">P <br>(Scatter)</button>
            <button class="control-btn check-btn" id="btnCheck">V <br>(Check)</button>
            <button class="control-btn ok-btn" id="btnItsOk">Its Ok for Me</button>
            <div class="control-row">
                <button id="resetCameraBtn" class="control-btn">Reset Camera</button>
                <button class="control-btn reset-btn" id="btnReset">Restart</button>
            </div>
            <button id="solveBtn" class="control-btn solve-btn">Solve <br>Puzzle</button>
        </div>
    </div>
    <div id="levelComplete">
        <h2>Level completed!</h2>
        <p>You have correctly assembled the cube.</p>
        <p>Time: <span id="levelTime">0</span>s</p>
        <p>Score: +<span id="levelScore">100</span></p>
        <button id="nextLevelBtn">Next level</button>
    </div>
    <div id="errorMsg"></div>

    <div id="onScreenControls">
        <div class="dpad-btn" id="changePieceBtn">Switch</div>
        <div class="dpad-btn" id="moveUp">&#9650;</div>
        <div class="dpad-btn" id="moveDown">&#9660;</div>
        <div class="dpad-btn" id="moveLeft">&#9664;</div>
        <div class="dpad-btn" id="moveRight">&#9654;</div>
        <div class="dpad-btn" id="moveForward">Fwd Z</div>
        <div class="dpad-btn" id="moveBackward">Bwd Z</div>
        <div class="dpad-btn" id="rotateBtn">Rotate</div>
        <div class="dpad-btn" id="fineTuneBtn">FineTune</div>
    </div>

    <div id="topCenterPanel">
        <p>Cube: <span id="cubeSizeDisplay">3x3x3</span></p>
        <p>Score: <span id="scoreDisplay">0</span></p>
        <p>Time: <span id="timerDisplay">0s</span></p>
        <div id="topCenterControls">
            <button id="hintBtn">💡 Hint</button>
            <button id="themeToggle">🌙 Theme</button>
            <button id="reCaptureBtn">🖼️ Re-capture Cube</button>
        </div>
    </div>

    <script>
        // Enhanced global variables
        const gameState = {
            canvas: null,
            engine: null,
            scene: null,
            camera: null,
            currentLevel: 1,
            pieces: [],
            selectedPieceIndex: 0,
            targetCubeSize: 3,
            isAnimating: false,
            gridSize: 1.0,
            isScattered: false,
            animationFrame: null,
            isFineTuneMode: false,
            lastClickTime: 0,
            doubleClickThreshold: 300,
            referenceImageTakenForCurrentAssembly: false,
            score: 0,
            levelStartTime: 0,
            currentTime: 0,
            timerInterval: null,
            moveHistory: [],
            maxUndoSteps: 20,
            soundEnabled: false,
            sounds: {},
            darkTheme: false,
            correctBlocks: 0,
            totalBlocks: 0
        };

        // Constants
        const COLORS = [
            new BABYLON.Color3(1, 0, 0),
            new BABYLON.Color3(0, 0, 1),
            new BABYLON.Color3(0, 1, 0),
            new BABYLON.Color3(1, 1, 0),
            new BABYLON.Color3(1, 0, 1),
            new BABYLON.Color3(0, 1, 1),
            new BABYLON.Color3(1, 0.5, 0),
            new BABYLON.Color3(0.5, 0, 0.5),
            new BABYLON.Color3(0, 0.5, 0),
            new BABYLON.Color3(0.8, 0.4, 0)
        ];

        // Texture URLs
        const TEXTURE_URLS = [
            "https://raw.githubusercontent.com/ravendano014/cubetris/refs/heads/main/cube.jpeg",
            "https://i.imgur.com/lXehwjZ.jpg",
            "https://i.imgur.com/7jDxfj0.jpg"

        ];

        // HDRI Environment Textures for PBR
        const HDRI_URLS = [
            "https://assets.babylonjs.com/environments/environmentSpecular.dds"
        ];

        // Scatter directions
        const SCATTER_DIRECTIONS = [
            new BABYLON.Vector3(1, 0, 0),
            new BABYLON.Vector3(-1, 0, 0),
            new BABYLON.Vector3(0, 1, 0),
            new BABYLON.Vector3(0, -1, 0),
            new BABYLON.Vector3(0, 0, 1),
            new BABYLON.Vector3(0, 0, -1)
        ];

        // Emissive colors for selection
        const NORMAL_EMISSIVE_COLOR = new BABYLON.Color3(0.3, 0.3, 0.3);
        const FINE_TUNE_EMISSIVE_COLOR = new BABYLON.Color3(0.5, 0.5, 0);
        const CORRECT_POSITION_COLOR = new BABYLON.Color3(0, 1, 0);

        // Initialize the game
        function initGame() {
            // Load sounds
            loadSounds();
            
            // Setup theme toggle
            document.getElementById('themeToggle').addEventListener('click', toggleTheme);
            
            // Setup re-capture button
            document.getElementById('reCaptureBtn').addEventListener('click', () => {
                gameState.referenceImageTakenForCurrentAssembly = false; // Allow re-capture
                captureReferenceImage();
            });
            
            // Setup start button
            document.getElementById('startButton').addEventListener('click', function() {
                document.getElementById('startScreen').style.display = 'none';
                startGame();
            });
            
            // Try to load saved game
            loadGame();
        }
        
        function startGame() {
            gameState.canvas = document.getElementById('renderCanvas');
            gameState.engine = new BABYLON.Engine(gameState.canvas, true, {
                preserveDrawingBuffer: true,
                stencil: true
            });
            gameState.scene = new BABYLON.Scene(gameState.engine);
            
            setupCamera();
            setupLights();
            setupScene();
            
            startLevel(gameState.currentLevel);
            
            setupControls();
            setupUI();
            setupPointerControls();
            
            gameState.engine.runRenderLoop(() => {
                gameState.scene.render();
            });
            
            window.addEventListener('resize', () => {
                gameState.engine.resize();
            });
        }
        
        function loadSounds() {
            gameState.sounds = {
                move: new Howl({ src: [''] }),
                rotate: new Howl({ src: [''] }),
                select: new Howl({ src: [''] }),
                success: new Howl({ src: [''] }),
                error: new Howl({ src: [''] }),
                scatter: new Howl({ src: [''] }),
                click: new Howl({ src: [''] })
            };
        }
        
        function playSound(soundName) {
            if (gameState.soundEnabled && gameState.sounds[soundName]) {
                gameState.sounds[soundName].play();
            }
        }
        
        function toggleTheme() {
            gameState.darkTheme = !gameState.darkTheme;
            const themeToggle = document.getElementById('themeToggle');
            if (gameState.darkTheme) {
                document.body.classList.add('dark-theme');
                document.body.classList.remove('light-theme');
                themeToggle.textContent = '☀️ Theme';
            } else {
                document.body.classList.add('light-theme');
                document.body.classList.remove('dark-theme');
                themeToggle.textContent = '🌙 Theme';
            }
            saveGame();
        }

        function setupCamera() {
            gameState.camera = new BABYLON.ArcRotateCamera(
                "Camera",
                -Math.PI / 2,
                Math.PI / 3,
                20,
                BABYLON.Vector3.Zero(),
                gameState.scene
            );
            gameState.camera.upperBetaLimit = Math.PI / 2;
            gameState.camera.lowerRadiusLimit = 5;
            gameState.camera.upperRadiusLimit = 25;
            gameState.camera.attachControl(gameState.canvas, true);
            gameState.camera.inputs.attached.keyboard.detachControl();
            
            gameState.camera.inertia = 0.8;
            gameState.camera.wheelPrecision = 50;
        }

        function setupLights() {
            new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), gameState.scene);
            const directionalLight = new BABYLON.DirectionalLight(
                "light2",
                new BABYLON.Vector3(0, -1, 1),
                gameState.scene
            );
            directionalLight.intensity = 0.7;
        }

        function setupScene() {
            gameState.scene.clearColor = new BABYLON.Color4(0.1, 0.1, 0.2, 1);
            gameState.scene.autoClear = true;
            gameState.scene.autoClearDepthAndStencil = true;
            
            gameState.scene.environmentTexture = new BABYLON.CubeTexture.CreateFromPrefilteredData(
                HDRI_URLS[0],
                gameState.scene
            );
            gameState.scene.environmentTexture.gammaSpace = false;
            
            gameState.scene.imageProcessingConfiguration.contrast = 1.6;
            gameState.scene.imageProcessingConfiguration.exposure = 1;
            
            gameState.scene.postProcessRenderPipelineManager = new BABYLON.PostProcessRenderPipelineManager();
            gameState.scene.postProcessRenderPipelineManager.addPipeline(new BABYLON.OutlineRenderer(gameState.scene));
        }

        function createTargetCube() {
            const targetCube = BABYLON.MeshBuilder.CreateBox(
                "targetCube",
                {size: gameState.targetCubeSize * gameState.gridSize},
                gameState.scene
            );
            targetCube.visibility = 0;
            
            const wireframe = BABYLON.MeshBuilder.CreateBox(
                "wireframe",
                {size: gameState.targetCubeSize * gameState.gridSize},
                gameState.scene
            );
            const wireMat = new BABYLON.StandardMaterial("wireMat", gameState.scene);
            wireMat.wireframe = true;
            wireMat.emissiveColor = new BABYLON.Color3(0, 1, 0);
            wireMat.alpha = 0.3;
            wireframe.material = wireMat;
            
            document.getElementById('cubeSizeDisplay').textContent =
                `${gameState.targetCubeSize}x${gameState.targetCubeSize}x${gameState.targetCubeSize}`;
        }

        function createGrid() {
            const halfSize = (gameState.targetCubeSize * gameState.gridSize) / 2;
            const lines = [];
            
            for (let x = -halfSize; x <= halfSize; x += gameState.gridSize) {
                lines.push([new BABYLON.Vector3(x, -halfSize, -halfSize), new BABYLON.Vector3(x, -halfSize, halfSize)]);
                lines.push([new BABYLON.Vector3(x, halfSize, -halfSize), new BABYLON.Vector3(x, halfSize, halfSize)]);
            }
            
            for (let z = -halfSize; z <= halfSize; z += gameState.gridSize) {
                lines.push([new BABYLON.Vector3(-halfSize, -halfSize, z), new BABYLON.Vector3(halfSize, -halfSize, z)]);
                lines.push([new BABYLON.Vector3(-halfSize, halfSize, z), new BABYLON.Vector3(halfSize, halfSize, z)]);
            }
            
            const grid = BABYLON.MeshBuilder.CreateLineSystem("grid", {lines: lines}, gameState.scene);
            grid.color = new BABYLON.Color3(0.5, 0.5, 0.5);
            grid.alpha = 0.5;

            const secondGridSize = 20;
            const secondHalfSize = (secondGridSize * gameState.gridSize) / 2;
            const offsetY = -(gameState.targetCubeSize * gameState.gridSize) / 2 - gameState.gridSize;

            const secondGridLines = [];
            for (let x = -secondHalfSize; x <= secondHalfSize; x += gameState.gridSize) {
                secondGridLines.push([new BABYLON.Vector3(x, offsetY, -secondHalfSize), new BABYLON.Vector3(x, offsetY, secondHalfSize)]);
            }
            
            for (let z = -secondHalfSize; z <= secondHalfSize; z += gameState.gridSize) {
                secondGridLines.push([new BABYLON.Vector3(-secondHalfSize, offsetY, z), new BABYLON.Vector3(secondHalfSize, offsetY, z)]);
            }

            const secondGrid = BABYLON.MeshBuilder.CreateLineSystem("secondGrid", {lines: secondGridLines}, gameState.scene);
            secondGrid.color = new BABYLON.Color3(0.8, 0.2, 0.2);
            secondGrid.alpha = 0.2;
        }

        function createPieces(blockPositions, pieceIndex, levelColorMode, textureUrl = null, materialType = 'normal') {
            const piece = {
                blocks: [],
                root: new BABYLON.TransformNode(`pieceRoot${pieceIndex}`, gameState.scene),
                position: new BABYLON.Vector3(0, 0, 0),
                rotation: 0,
                originalPositions: [],
                assembledPosition: new BABYLON.Vector3(0, 0, 0),
                assembledRotation: 0,
                index: pieceIndex
            };
            
            const center = new BABYLON.Vector3(0, 0, 0);
            blockPositions.forEach(pos => center.addInPlace(pos));
            center.scaleInPlace(1.0 / blockPositions.length);
            
            // Aleatorizar efectos para esta pieza
            const useTransparency = Math.random() > 0.7; // 30% de probabilidad
            const useGradient = Math.random() > 0.6; // 40% de probabilidad
            const useReflection = Math.random() > 0.5; // 50% de probabilidad
            const randomEffect = Math.random();
            
            let normalMaterial;
            let darkerMaterial;

            if (materialType !== 'normal' || randomEffect > 0.7) {
                normalMaterial = new BABYLON.PBRMaterial(`normalPBRMat${pieceIndex}`, gameState.scene);
                darkerMaterial = new BABYLON.PBRMaterial(`darkerPBRMat${pieceIndex}`, gameState.scene);
                
                [normalMaterial, darkerMaterial].forEach(mat => {
                    mat.environmentTexture = gameState.scene.environmentTexture;
                    mat.useAmbientOcclusionFromMetallicTextureRed = true;
                    mat.useRoughnessFromMetallicTextureGreen = true;
                    mat.useMetallnessFromMetallicTextureBlue = true;
                    mat.directIntensity = 1.5;
                    
                    // Aplicar efectos aleatorios
                    if (useTransparency) {
                        mat.alpha = 0.5 + Math.random() * 0.5; // Transparencia entre 0.5 y 1
                        mat.transparencyMode = BABYLON.PBRMaterial.PBRTRANSPARENCYMODE_ALPHABLEND;
                    }
                    
                    if (useReflection) {
                        mat.metallic = 0.5 + Math.random() * 0.5; // 0.5 a 1.0
                        mat.roughness = 0.1 + Math.random() * 0.4; // 0.1 a 0.5
                    }
                });

                // Combinar con efectos específicos del nivel
                switch(materialType) {
                    case 'metallic':
                        normalMaterial.albedoColor = new BABYLON.Color3(0.9, 0.8, 0.4);
                        normalMaterial.metallic = Math.max(0.7, normalMaterial.metallic || 0);
                        normalMaterial.roughness = Math.min(0.4, normalMaterial.roughness || 1);
                        break;
                    case 'glassy':
                        normalMaterial.albedoColor = new BABYLON.Color3(0.8, 0.9, 1.0);
                        normalMaterial.metallic = 0.0;
                        normalMaterial.roughness = 0.0;
                        normalMaterial.alpha = normalMaterial.alpha || 0.7;
                        normalMaterial.linkRefractionWithTransparency = true;
                        normalMaterial.indexOfRefraction = 0.98;
                        normalMaterial.transparencyMode = BABYLON.PBRMaterial.PBRTRANSPARENCYMODE_ALPHABLEND;
                        break;
                    case 'brightMetallic':
                        normalMaterial.albedoColor = new BABYLON.Color3(0.95, 0.95, 0.99);
                        normalMaterial.metallic = 1.0;
                        normalMaterial.roughness = 0.1;
                        break;
                    case 'texturedMetallic':
                        if (textureUrl) {
                            normalMaterial.albedoTexture = new BABYLON.Texture(textureUrl, gameState.scene);
                            normalMaterial.metallicTexture = normalMaterial.albedoTexture;
                        } else {
                            normalMaterial.albedoColor = new BABYLON.Color3(0.7, 0.4, 0.2);
                        }
                        normalMaterial.metallic = 0.9;
                        normalMaterial.roughness = 0.4;
                        break;
                }
            } else {
                // Material estándar con efectos aleatorios
                if (textureUrl) {
                    normalMaterial = new BABYLON.StandardMaterial(`normalMat${pieceIndex}`, gameState.scene);
                    normalMaterial.diffuseTexture = new BABYLON.Texture(textureUrl, gameState.scene);
                    normalMaterial.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                    normalMaterial.emissiveColor = new BABYLON.Color3(0, 0, 0);
                    normalMaterial.diffuseTexture.uScale = 2;
                    normalMaterial.diffuseTexture.vScale = 2;

                    darkerMaterial = new BABYLON.StandardMaterial(`darkerMat${pieceIndex}`, gameState.scene);
                    darkerMaterial.diffuseTexture = new BABYLON.Texture(textureUrl, gameState.scene);
                    darkerMaterial.diffuseColor = new BABYLON.Color3(0.6, 0.6, 0.6);
                    darkerMaterial.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                    darkerMaterial.emissiveColor = new BABYLON.Color3(0, 0, 0);
                    darkerMaterial.diffuseTexture.uScale = 2;
                    darkerMaterial.diffuseTexture.vScale = 2;
                } else {
                    let pieceColor;
                    const randomComponent = 0.5 + Math.random() * 0.5;

                    switch (levelColorMode) {
                        case 'grayscale':
                            const grayValue = 0.3 + Math.random() * 0.5;
                            pieceColor = new BABYLON.Color3(grayValue, grayValue, grayValue);
                            break;
                        case 'yellow':
                            pieceColor = new BABYLON.Color3(1, randomComponent, 0);
                            break;
                        case 'red':
                            pieceColor = new BABYLON.Color3(randomComponent, 0, 0);
                            break;
                        case 'blue':
                            pieceColor = new BABYLON.Color3(0, 0, randomComponent);
                            break;
                        case 'green':
                            pieceColor = new BABYLON.Color3(0, randomComponent, 0);
                            break;
                        case 'purple':
                            const purpleValue = 0.5 + Math.random() * 0.5;
                            pieceColor = new BABYLON.Color3(purpleValue, 0, purpleValue);
                            break;
                        case 'orange':
                            const orangeGreenValue = 0.2 + Math.random() * 0.4;
                            pieceColor = new BABYLON.Color3(1, orangeGreenValue, 0);
                            break;
                        case 'normal':
                        default:
                            pieceColor = COLORS[pieceIndex % COLORS.length];
                            break;
                    }

                    // Aplicar degradado de color si está activado
                    if (useGradient) {
                        const gradientFactor = 0.3 + Math.random() * 0.4; // 0.3 a 0.7
                        const gradientColor = pieceColor.scale(gradientFactor);
                        
                        normalMaterial = new BABYLON.StandardMaterial(`normalMat${pieceIndex}`, gameState.scene);
                        normalMaterial.diffuseColor = pieceColor;
                        normalMaterial.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                        normalMaterial.emissiveColor = new BABYLON.Color3(0, 0, 0);
                        
                        // Aplicar transparencia si está activada
                        if (useTransparency) {
                            normalMaterial.alpha = 0.6 + Math.random() * 0.4; // 0.6 a 1.0
                            normalMaterial.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND;
                        }
                        
                        // Aplicar reflexión si está activada
                        if (useReflection) {
                            normalMaterial.reflectionTexture = gameState.scene.environmentTexture;
                            normalMaterial.reflectionFresnel = true;
                            normalMaterial.reflectionFresnelParameters = new BABYLON.FresnelParameters();
                            normalMaterial.reflectionFresnelParameters.bias = 0.1;
                            normalMaterial.reflectionFresnelParameters.power = 2;
                        }

                        darkerMaterial = new BABYLON.StandardMaterial(`darkerMat${pieceIndex}`, gameState.scene);
                        darkerMaterial.diffuseColor = gradientColor;
                        darkerMaterial.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                        darkerMaterial.emissiveColor = new BABYLON.Color3(0, 0, 0);
                        
                        if (useTransparency) {
                            darkerMaterial.alpha = normalMaterial.alpha * 0.8;
                            darkerMaterial.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND;
                        }
                        
                        if (useReflection) {
                            darkerMaterial.reflectionTexture = gameState.scene.environmentTexture;
                            darkerMaterial.reflectionFresnel = true;
                            darkerMaterial.reflectionFresnelParameters = new BABYLON.FresnelParameters();
                            darkerMaterial.reflectionFresnelParameters.bias = 0.2;
                            darkerMaterial.reflectionFresnelParameters.power = 1.5;
                        }
                    } else {
                        normalMaterial = new BABYLON.StandardMaterial(`normalMat${pieceIndex}`, gameState.scene);
                        normalMaterial.diffuseColor = pieceColor;
                        normalMaterial.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                        normalMaterial.emissiveColor = new BABYLON.Color3(0, 0, 0);

                        const darkerColor = pieceColor.scale(0.6);
                        darkerMaterial = new BABYLON.StandardMaterial(`darkerMat${pieceIndex}`, gameState.scene);
                        darkerMaterial.diffuseColor = darkerColor;
                        darkerMaterial.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                        darkerMaterial.emissiveColor = new BABYLON.Color3(0, 0, 0);
                        
                        // Aplicar transparencia si está activada
                        if (useTransparency) {
                            normalMaterial.alpha = 0.6 + Math.random() * 0.4; // 0.6 a 1.0
                            normalMaterial.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND;
                            darkerMaterial.alpha = normalMaterial.alpha * 0.8;
                            darkerMaterial.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND;
                        }
                        
                        // Aplicar reflexión si está activada
                        if (useReflection) {
                            normalMaterial.reflectionTexture = gameState.scene.environmentTexture;
                            normalMaterial.reflectionFresnel = true;
                            normalMaterial.reflectionFresnelParameters = new BABYLON.FresnelParameters();
                            normalMaterial.reflectionFresnelParameters.bias = 0.1;
                            normalMaterial.reflectionFresnelParameters.power = 2;
                            darkerMaterial.reflectionTexture = gameState.scene.environmentTexture;
                            darkerMaterial.reflectionFresnel = true;
                            darkerMaterial.reflectionFresnelParameters = new BABYLON.FresnelParameters();
                            darkerMaterial.reflectionFresnelParameters.bias = 0.2;
                            darkerMaterial.reflectionFresnelParameters.power = 1.5;
                        }
                    }
                }
            }
            // Define FaceUV if a specific texture is used for it
            let boxOptions = {size: 0.9 * gameState.gridSize};
            if (textureUrl === "https://raw.githubusercontent.com/ravendano014/cubetris/refs/heads/main/cube.jpeg") {
                var columns = 12;
                var rows = 2;
                var faceUV = new Array(6);
                for (var i = 0; i < 6; i++) {
                    faceUV[i] = new BABYLON.Vector4(i / columns, 0, (i + 1) / columns, 1 / rows);
                }
                boxOptions.faceUV = faceUV;
                boxOptions.wrap = true;
            }

            const pieceAssembledGlobalPosition = new BABYLON.Vector3(
                center.x * gameState.gridSize,
                center.y * gameState.gridSize,
                center.z * gameState.gridSize
            );

            blockPositions.forEach((pos, index) => {
                const block = BABYLON.MeshBuilder.CreateBox(
                    `block${pieceIndex}_${index}`,
                    boxOptions,
                    gameState.scene
                );
                block.parent = piece.root;
                const relativePos = pos.subtract(center);
                block.position = relativePos.clone();
                piece.originalPositions.push(relativePos.clone());
                
                const absoluteBlockX = pos.x;
                const absoluteBlockY = pos.y;
                const absoluteBlockZ = pos.z;

                const halfTargetSize = (gameState.targetCubeSize - 1) / 2;
                let isOuterBlock = false;
                if (Math.abs(absoluteBlockX) === halfTargetSize ||
                    Math.abs(absoluteBlockY) === halfTargetSize ||
                    Math.abs(absoluteBlockZ) === halfTargetSize) {
                    isOuterBlock = true;
                }
                
                block.material = isOuterBlock ? darkerMaterial : normalMaterial;
                block.isPickable = true;
                block.pieceIndex = pieceIndex;
                piece.blocks.push(block);
            });

            piece.assembledPosition = pieceAssembledGlobalPosition;
            gameState.pieces.push(piece);
            return piece;
        }

        function createPiecesForLevelInternal(level, levelColorMode, textureToUse) {
            let numPieces;
            if (level === 14) {
                numPieces = 8;
            } else if (level < 14) {
                numPieces = 4 + Math.floor(level / 2);
                if (numPieces > 10) numPieces = 10;
            } else {
                numPieces = 8 + Math.floor((level - 14) / 2);
                if (numPieces > 12) numPieces = 12;
            }

            let materialEffect = 'normal';
            const effectTypes = ['metallic', 'glassy', 'brightMetallic', 'texturedMetallic'];
            if (level % 5 === 0 && level > 1) {
                const effectIndex = (Math.floor((level / 2) - 1) % effectTypes.length);
                materialEffect = effectTypes[effectIndex];
            }
            if (level === 3) {
                materialEffect = 'normal';
                textureToUse = "https://raw.githubusercontent.com/ravendano014/cubetris/refs/heads/main/cube.jpeg";
            }

            const allBlocks = [];
            const halfSize = (gameState.targetCubeSize - 1) / 2;
            for (let x = -halfSize; x <= halfSize; x++) {
                for (let y = -halfSize; y <= halfSize; y++) {
                    for (let z = -halfSize; z <= halfSize; z++) {
                        allBlocks.push(new BABYLON.Vector3(x, y, z));
                    }
                }
            }

            let blocksPerPiece = Math.floor(allBlocks.length / numPieces);
            if (level > 14) {
                const minBlocks = Math.max(3, Math.floor(blocksPerPiece * 0.7));
                const maxBlocks = Math.min(allBlocks.length, Math.ceil(blocksPerPiece * 1.3));
                blocksPerPiece = Math.floor(Math.random() * (maxBlocks - minBlocks + 1)) + minBlocks;
            }

            for (let i = 0; i < numPieces; i++) {
                const pieceBlocks = [];
                const blocksToTake = (i === numPieces - 1) ? allBlocks.length : blocksPerPiece;

                if (allBlocks.length > 0) {
                    const startIndex = Math.floor(Math.random() * allBlocks.length);
                    pieceBlocks.push(allBlocks[startIndex]);
                    allBlocks.splice(startIndex, 1);

                    for (let j = 1; j < blocksToTake && allBlocks.length > 0; j++) {
                        let addedBlock = false;
                        for (let k = 0; k < allBlocks.length && !addedBlock; k++) {
                            const testBlock = allBlocks[k];
                            for (let l = 0; l < pieceBlocks.length; l++) {
                                if (areBlocksAdjacent(testBlock, pieceBlocks[l])) {
                                    pieceBlocks.push(testBlock);
                                    allBlocks.splice(k, 1);
                                    addedBlock = true;
                                    break;
                                }
                            }
                        }
                        // Fallback: If no adjacent block found, just take a random one
                        if (!addedBlock && allBlocks.length > 0) {
                            const randomIndex = Math.floor(Math.random() * allBlocks.length);
                            pieceBlocks.push(allBlocks[randomIndex]);
                            allBlocks.splice(randomIndex, 1);
                        }
                    }
                }
                createPieces(pieceBlocks, i, levelColorMode, textureToUse, materialEffect);
            }
            gameState.totalBlocks = gameState.targetCubeSize * gameState.targetCubeSize * gameState.targetCubeSize;
            gameState.correctBlocks = 0;
            updateProgressBar();
        }

        function areBlocksAdjacent(block1, block2) {
            const dx = Math.abs(block1.x - block2.x);
            const dy = Math.abs(block1.y - block2.y);
            const dz = Math.abs(block1.z - block2.z);
            return (dx === 1 && dy === 0 && dz === 0) ||
                   (dx === 0 && dy === 1 && dz === 0) ||
                   (dx === 0 && dy === 0 && dz === 1);
        }

        function assemblePieces() {
            gameState.pieces.forEach(piece => {
                piece.position = piece.assembledPosition.clone();
                piece.root.position = piece.assembledPosition.clone();
                piece.rotation = piece.assembledRotation;
                piece.root.rotation.y = piece.assembledRotation;
                updateBlockPositions(piece);
            });
            gameState.isScattered = false;
        }

        function captureReferenceImage() {
            if (!gameState.referenceImageTakenForCurrentAssembly) {
                const gameInfo = document.getElementById('gameInfo');
                const controls = document.getElementById('controls');
                const levelComplete = document.getElementById('levelComplete');
                const errorMsg = document.getElementById('errorMsg');
                const onScreenControls = document.getElementById('onScreenControls');
                const topCenterPanel = document.getElementById('topCenterPanel'); // Adjusted to topCenterPanel
                
                // Hide relevant UI elements for a clean screenshot
                if (gameInfo) gameInfo.style.display = 'none';
                if (controls) controls.style.display = 'none';
                if (levelComplete) levelComplete.style.display = 'none';
                if (errorMsg) errorMsg.style.display = 'none';
                if (onScreenControls) onScreenControls.style.display = 'none';
                if (topCenterPanel) topCenterPanel.style.display = 'none'; // Hide the top center panel too

                setTimeout(() => {
                    BABYLON.ScreenshotTools.CreateScreenshot(gameState.engine, gameState.camera, {
                        width: 512,
                        height: 512,
                        precision: 1
                    }, (data) => {
                        const referenceImage = document.getElementById('referenceImage');
                        const referenceImageContainer = document.getElementById('referenceImageContainer');
                        referenceImage.src = data;
                        referenceImageContainer.style.display = 'block';

                        // Show UI elements again
                        if (gameInfo) gameInfo.style.display = 'block';
                        if (controls) controls.style.display = 'block';
                        if (onScreenControls) onScreenControls.style.display = 'grid';
                        if (topCenterPanel) topCenterPanel.style.display = 'flex'; // Show the top center panel again
                        
                        gameState.referenceImageTakenForCurrentAssembly = true;
                    });
                }, 50); // Small delay to ensure UI is hidden before screenshot
            }
        }

        function scatterPieces() {
            if (gameState.isScattered || gameState.isAnimating) return;
            playSound('scatter');
            saveMoveToHistory();

            const minDistance = gameState.targetCubeSize * gameState.gridSize * 1.5;
            const maxDistance = gameState.targetCubeSize * gameState.gridSize * 2.5;
            const directions = [...SCATTER_DIRECTIONS];
            const usedDirections = new Set();

            gameState.pieces.forEach((piece, index) => {
                let direction;
                let attempts = 0;
                const maxAttempts = 20; // Limit attempts to find a unique direction

                do {
                    const dirIndex = Math.floor(Math.random() * directions.length);
                    direction = directions[dirIndex];
                    attempts++;
                    if (attempts >= maxAttempts) {
                        // If too many attempts, clear used directions to allow reuse
                        usedDirections.clear();
                        break;
                    }
                } while (usedDirections.has(direction.toString()) && attempts < maxAttempts);

                usedDirections.add(direction.toString());

                const distanceMultiplier = Math.floor(minDistance/gameState.gridSize) + Math.floor(Math.random() * ((maxDistance-minDistance)/gameState.gridSize));
                const distance = distanceMultiplier * gameState.gridSize;

                const newPosition = new BABYLON.Vector3(
                    direction.x * distance,
                    direction.y * distance,
                    direction.z * distance
                );

                piece.position = newPosition;
                piece.root.position = piece.position.clone();
                piece.rotation = Math.floor(Math.random() * 4) * Math.PI / 2;
                piece.root.rotation.y = piece.rotation;
                updateBlockPositions(piece);
            });
            gameState.isScattered = true;
            gameState.correctBlocks = 0;
            updateProgressBar();
        }

        function updateBlockPositions(piece) {
            piece.blocks.forEach((block, index) => {
                const originalPos = piece.originalPositions[index];
                const rotatedPos = new BABYLON.Vector3(
                    originalPos.z * Math.sin(piece.rotation) + originalPos.x * Math.cos(piece.rotation),
                    originalPos.y,
                    originalPos.z * Math.cos(piece.rotation) - originalPos.x * Math.sin(piece.rotation)
                );
                block.position = rotatedPos;
            });
        }

        function selectPiece(index, isDoubleClick = false) {
            if (gameState.isAnimating || index < 0 || index >= gameState.pieces.length) return;
            playSound('select');

            // Deselect previously selected piece
            if (gameState.pieces[gameState.selectedPieceIndex]) {
                gameState.pieces[gameState.selectedPieceIndex].blocks.forEach(block => {
                    block.renderOutline = false;
                    block.outlineColor = BABYLON.Color3.Black();
                    block.outlineWidth = 0;
                    // Restore original emissive color based on fine tune mode
                    block.material.emissiveColor = gameState.isFineTuneMode ? FINE_TUNE_EMISSIVE_COLOR : NORMAL_EMISSIVE_COLOR;
                });
            }

            // Select new piece
            gameState.selectedPieceIndex = index;
            const selectedPiece = gameState.pieces[gameState.selectedPieceIndex];
            selectedPiece.blocks.forEach(block => {
                block.renderOutline = true;
                block.outlineColor = new BABYLON.Color3(0, 1, 1); // Cyan outline
                block.outlineWidth = 0.05;
                block.material.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5); // Brighter emissive when selected
            });

            // If double-clicked, scatter this piece
            if (isDoubleClick) {
                scatterSelectedPiece(selectedPiece);
            }
        }

        function scatterSelectedPiece(piece) {
            if (gameState.isAnimating) return;
            playSound('scatter');
            saveMoveToHistory();

            const minDistance = gameState.gridSize * 3;
            const maxDistance = gameState.gridSize * 6;
            const direction = SCATTER_DIRECTIONS[Math.floor(Math.random() * SCATTER_DIRECTIONS.length)];
            const distance = minDistance + Math.random() * (maxDistance - minDistance);

            const newPosition = new BABYLON.Vector3(
                piece.position.x + direction.x * distance,
                piece.position.y + direction.y * distance,
                piece.position.z + direction.z * distance
            );

            piece.position = newPosition;
            piece.root.position = piece.position.clone();
            piece.rotation = Math.floor(Math.random() * 4) * Math.PI / 2;
            piece.root.rotation.y = piece.rotation;
            updateBlockPositions(piece);

            // Re-evaluate correctness after scattering a piece
            checkCurrentAssembly();
        }

        function moveSelectedPiece(direction) {
            if (gameState.isAnimating || !gameState.pieces[gameState.selectedPieceIndex]) return;
            playSound('move');
            saveMoveToHistory();

            const selectedPiece = gameState.pieces[gameState.selectedPieceIndex];
            const moveAmount = gameState.isFineTuneMode ? gameState.gridSize / 10 : gameState.gridSize;

            switch (direction) {
                case 'up':
                    selectedPiece.position.y += moveAmount;
                    break;
                case 'down':
                    selectedPiece.position.y -= moveAmount;
                    break;
                case 'left':
                    selectedPiece.position.x -= moveAmount;
                    break;
                case 'right':
                    selectedPiece.position.x += moveAmount;
                    break;
                case 'forward':
                    selectedPiece.position.z += moveAmount;
                    break;
                case 'backward':
                    selectedPiece.position.z -= moveAmount;
                    break;
            }
            selectedPiece.root.position = selectedPiece.position.clone();
            checkCurrentAssembly();
        }

        function rotateSelectedPiece() {
            if (gameState.isAnimating || !gameState.pieces[gameState.selectedPieceIndex]) return;
            playSound('rotate');
            saveMoveToHistory();

            const selectedPiece = gameState.pieces[gameState.selectedPieceIndex];
            selectedPiece.rotation = (selectedPiece.rotation + Math.PI / 2) % (Math.PI * 2);
            selectedPiece.root.rotation.y = selectedPiece.rotation;
            updateBlockPositions(selectedPiece);
            checkCurrentAssembly();
        }

        function checkCurrentAssembly() {
            let correctBlocksCount = 0;
            const assembledBlockPositions = new Set();
            const halfSize = (gameState.targetCubeSize - 1) / 2;

            gameState.pieces.forEach(piece => {
                piece.blocks.forEach(block => {
                    const worldPos = block.absolutePosition;
                    const snappedX = Math.round(worldPos.x / gameState.gridSize) * gameState.gridSize;
                    const snappedY = Math.round(worldPos.y / gameState.gridSize) * gameState.gridSize;
                    const snappedZ = Math.round(worldPos.z / gameState.gridSize) * gameState.gridSize;

                    // Convert snapped world position to grid coordinates (0-indexed or centered)
                    const gridX = Math.round(snappedX / gameState.gridSize);
                    const gridY = Math.round(snappedY / gameState.gridSize);
                    const gridZ = Math.round(snappedZ / gameState.gridSize);

                    const targetMin = -halfSize;
                    const targetMax = halfSize;

                    // Check if block is within the target cube bounds and not overlapping
                    if (gridX >= targetMin && gridX <= targetMax &&
                        gridY >= targetMin && gridY <= targetMax &&
                        gridZ >= targetMin && gridZ <= targetMax) {
                        
                        const positionKey = `${gridX},${gridY},${gridZ}`;
                        if (!assembledBlockPositions.has(positionKey)) {
                            assembledBlockPositions.add(positionKey);
                            correctBlocksCount++;
                            // Optionally change color to green for correctly placed blocks
                            block.material.emissiveColor = CORRECT_POSITION_COLOR;
                        } else {
                            // Overlapping block
                            block.material.emissiveColor = new BABYLON.Color3(1, 0, 0); // Red for overlap
                        }
                    } else {
                        // Block outside target area
                        block.material.emissiveColor = new BABYLON.Color3(1, 0.5, 0); // Orange for out of bounds
                    }
                });
            });

            gameState.correctBlocks = correctBlocksCount;
            updateProgressBar();

            if (gameState.correctBlocks === gameState.totalBlocks) {
                playSound('success');
                showLevelComplete();
            }
        }

        function updateProgressBar() {
            const progressFill = document.getElementById('progressFill');
            const percentage = (gameState.correctBlocks / gameState.totalBlocks) * 100;
            progressFill.style.width = `${percentage}%`;
            if (percentage === 100) {
                progressFill.style.backgroundColor = '#00FF00'; // Green when complete
            } else {
                progressFill.style.backgroundColor = '#4CAF50'; // Default green
            }
        }

        function toggleFineTuneMode() {
            gameState.isFineTuneMode = !gameState.isFineTuneMode;
            document.getElementById('fineTuneStatus').textContent =
                gameState.isFineTuneMode ? 'ACTIVATED' : 'DEACTIVATED';
            // Update emissive color for selected piece
            if (gameState.pieces[gameState.selectedPieceIndex]) {
                gameState.pieces[gameState.selectedPieceIndex].blocks.forEach(block => {
                    block.material.emissiveColor = gameState.isFineTuneMode ? FINE_TUNE_EMISSIVE_COLOR : NORMAL_EMISSIVE_COLOR;
                });
            }
            playSound('click');
        }

        function showLevelComplete() {
            clearInterval(gameState.timerInterval);
            const levelTime = Math.floor((Date.now() - gameState.levelStartTime) / 1000);
            const scoreEarned = Math.max(0, 500 - levelTime); // Example scoring
            gameState.score += scoreEarned;
            saveGame();

            document.getElementById('levelComplete').style.display = 'block';
            document.getElementById('levelTime').textContent = levelTime;
            document.getElementById('levelScore').textContent = scoreEarned;
            document.getElementById('scoreDisplay').textContent = gameState.score;
        }

        function nextLevel() {
            playSound('click');
            document.getElementById('levelComplete').style.display = 'none';
            gameState.currentLevel++;
            startLevel(gameState.currentLevel);
            saveGame();
        }

        function startLevel(level) {
            // Dispose of old pieces
            gameState.pieces.forEach(piece => {
                piece.blocks.forEach(block => block.dispose());
                piece.root.dispose();
            });
            gameState.pieces = [];
            gameState.selectedPieceIndex = 0;
            gameState.isScattered = false;
            gameState.referenceImageTakenForCurrentAssembly = false;

            // Determine cube size based on level
            gameState.targetCubeSize = 3 + Math.floor(level / 5);
            if (gameState.targetCubeSize > 5) gameState.targetCubeSize = 5; // Cap at 5x5x5

            // Determine level color mode and texture
            let levelColorMode = 'normal';
            let textureToUse = null;
            if (level % 2 === 0) { // Every even level has a specific color mode
                const colorModes = ['yellow', 'red', 'blue', 'green', 'purple', 'orange', 'grayscale'];
                levelColorMode = colorModes[Math.floor((level / 2 - 1) % colorModes.length)];
            }
            if (level === 3) {
                textureToUse = TEXTURE_URLS[0]; // Specific texture for level 3
            } else if (level === 6) {
                textureToUse = TEXTURE_URLS[1];
            } else if (level === 9) {
                textureToUse = TEXTURE_URLS[2];
            }

            // Recreate scene elements
            gameState.scene.dispose();
            gameState.scene = new BABYLON.Scene(gameState.engine);
            setupLights();
            setupScene();
            setupCamera(); // Re-attach control
            createTargetCube();
            createGrid();
            createPiecesForLevelInternal(level, levelColorMode, textureToUse);

            assemblePieces(); // Start assembled
            captureReferenceImage(); // Capture initial assembled state

            // Reset timer
            clearInterval(gameState.timerInterval);
            gameState.levelStartTime = Date.now();
            gameState.currentTime = 0;
            gameState.timerInterval = setInterval(updateTimer, 1000);

            // Update UI
            document.getElementById('levelDisplay').textContent = gameState.currentLevel;
            document.getElementById('timerDisplay').textContent = '0s';
            document.getElementById('fineTuneStatus').textContent = 'DEACTIVATED';
            gameState.isFineTuneMode = false;
            updateProgressBar();
            
            // Re-apply theme in case scene dispose removed classes
            toggleTheme(); // Call to apply current theme state
        }

        function updateTimer() {
            gameState.currentTime = Math.floor((Date.now() - gameState.levelStartTime) / 1000);
            document.getElementById('timerDisplay').textContent = `${gameState.currentTime}s`;
        }

        function solvePuzzle() {
            if (gameState.isAnimating) return;
            playSound('success');
            saveMoveToHistory();
            assemblePieces();
            checkCurrentAssembly();
        }

        function resetCamera() {
            if (gameState.camera) {
                gameState.camera.alpha = -Math.PI / 2;
                gameState.camera.beta = Math.PI / 3;
                gameState.camera.radius = 20;
            }
        }

        function giveHint() {
            // Implement hint logic here
            // For example, highlight a randomly misplaced block, or show the correct position of one block.
            // This is a placeholder for actual hint functionality.
            showError("Hint functionality not yet fully implemented, but here's a thought: Look for misaligned pieces!", 3000);
            playSound('click');
        }

        function setupUI() {
            // Attach event listeners for existing buttons
            document.getElementById('btnScatter').addEventListener('click', scatterPieces);
            document.getElementById('btnCheck').addEventListener('click', checkCurrentAssembly);
            document.getElementById('btnItsOk').addEventListener('click', checkCurrentAssembly); // Same as check for now
            document.getElementById('btnReset').addEventListener('click', () => {
                startLevel(gameState.currentLevel); // Restart current level
                playSound('click');
            });
            document.getElementById('nextLevelBtn').addEventListener('click', nextLevel);
            document.getElementById('solveBtn').addEventListener('click', solvePuzzle);
            document.getElementById('resetCameraBtn').addEventListener('click', resetCamera);
            document.getElementById('hintBtn').addEventListener('click', giveHint);

            document.getElementById('moveUp').addEventListener('click', () => moveSelectedPiece('up'));
            document.getElementById('moveDown').addEventListener('click', () => moveSelectedPiece('down'));
            document.getElementById('moveLeft').addEventListener('click', () => moveSelectedPiece('left'));
            document.getElementById('moveRight').addEventListener('click', () => moveSelectedPiece('right'));
            document.getElementById('moveForward').addEventListener('click', () => moveSelectedPiece('forward'));
            document.getElementById('moveBackward').addEventListener('click', () => moveSelectedPiece('backward'));
            document.getElementById('rotateBtn').addEventListener('click', rotateSelectedPiece);
            document.getElementById('changePieceBtn').addEventListener('click', () => selectPiece((gameState.selectedPieceIndex + 1) % gameState.pieces.length));
            document.getElementById('fineTuneBtn').addEventListener('click', toggleFineTuneMode);
        }

        function setupControls() {
            // Keyboard controls
            window.addEventListener('keydown', (event) => {
                if (gameState.isAnimating) return;
                const selectedPiece = gameState.pieces[gameState.selectedPieceIndex];
                if (!selectedPiece) return;

                switch (event.key) {
                    case 'w': // Move Up
                        moveSelectedPiece('up');
                        break;
                    case 's': // Move Down
                        moveSelectedPiece('down');
                        break;
                    case 'a': // Move Left
                        moveSelectedPiece('left');
                        break;
                    case 'd': // Move Right
                        moveSelectedPiece('right');
                        break;
                    case 'q': // Move Forward (Z+)
                        moveSelectedPiece('forward');
                        break;
                    case 'e': // Move Backward (Z-)
                        moveSelectedPiece('backward');
                        break;
                    case 'r': // Rotate
                        rotateSelectedPiece();
                        break;
                    case ' ': // Space - Change Piece
                        event.preventDefault(); // Prevent page scroll
                        selectPiece((gameState.selectedPieceIndex + 1) % gameState.pieces.length);
                        break;
                    case 'p': // Scatter all pieces
                        scatterPieces();
                        break;
                    case 'v': // Check assembly
                        checkCurrentAssembly();
                        break;
                    case 'm': // Toggle fine-tune mode
                        toggleFineTuneMode();
                        break;
                    case 'z': // Undo move
                        if (event.ctrlKey || event.metaKey) { // Ctrl+Z or Cmd+Z
                            undoMove();
                        }
                        break;
                    case 'x': // Redo move
                        if (event.ctrlKey || event.metaKey) { // Ctrl+X or Cmd+X
                            redoMove();
                        }
                        break;
                    case 'h': // Hint
                        giveHint();
                        break;
                    case 't': // Toggle theme
                        toggleTheme();
                        break;
                    case 'c': // Re-capture cube image
                        gameState.referenceImageTakenForCurrentAssembly = false;
                        captureReferenceImage();
                        break;
                }
            });
        }

        function setupPointerControls() {
            gameState.scene.onPointerObservable.add((pointerInfo) => {
                switch (pointerInfo.type) {
                    case BABYLON.PointerEventTypes.POINTERDOWN:
                        const pickResult = gameState.scene.pick(
                            gameState.scene.pointerX,
                            gameState.scene.pointerY
                        );
                        if (pickResult.hit && pickResult.pickedMesh && pickResult.pickedMesh.pieceIndex !== undefined) {
                            const now = Date.now();
                            if (now - gameState.lastClickTime < gameState.doubleClickThreshold &&
                                pickResult.pickedMesh.pieceIndex === gameState.selectedPieceIndex) {
                                // Double click on the same piece
                                selectPiece(pickResult.pickedMesh.pieceIndex, true); // Pass true for double click
                            } else {
                                selectPiece(pickResult.pickedMesh.pieceIndex);
                            }
                            gameState.lastClickTime = now;
                        }
                        break;
                }
            });
        }

        function saveMoveToHistory() {
            const currentPositions = gameState.pieces.map(piece => ({
                position: piece.position.clone(),
                rotation: piece.rotation,
                isScattered: gameState.isScattered
            }));
            gameState.moveHistory.push(currentPositions);
            if (gameState.moveHistory.length > gameState.maxUndoSteps) {
                gameState.moveHistory.shift(); // Remove oldest move
            }
        }

        function undoMove() {
            if (gameState.moveHistory.length > 1) { // Need at least two states to undo one move
                gameState.moveHistory.pop(); // Remove current state
                const previousState = gameState.moveHistory[gameState.moveHistory.length - 1];
                applyState(previousState);
                checkCurrentAssembly(); // Re-check after undo
                playSound('click');
            } else {
                showError("Cannot undo further.", 2000);
            }
        }

        function redoMove() {
            // This would require a separate 'redo' history stack, which is not implemented here.
            // For now, this function is a placeholder or can display an error.
            showError("Redo functionality not implemented.", 2000);
        }

        function applyState(state) {
            gameState.pieces.forEach((piece, index) => {
                const savedPieceState = state[index];
                piece.position = savedPieceState.position.clone();
                piece.root.position = savedPieceState.position.clone();
                piece.rotation = savedPieceState.rotation;
                piece.root.rotation.y = savedPieceState.rotation;
                updateBlockPositions(piece);
            });
            gameState.isScattered = state[0].isScattered; // Assuming scattered state is consistent across pieces
        }

        function saveGame() {
            const savedState = {
                currentLevel: gameState.currentLevel,
                score: gameState.score,
                darkTheme: gameState.darkTheme
            };
            localStorage.setItem('cubetrisGameState', JSON.stringify(savedState));
        }

        function loadGame() {
            const savedState = localStorage.getItem('cubetrisGameState');
            if (savedState) {
                const parsedState = JSON.parse(savedState);
                gameState.currentLevel = parsedState.currentLevel || 1;
                gameState.score = parsedState.score || 0;
                gameState.darkTheme = parsedState.darkTheme !== undefined ? parsedState.darkTheme : false;
                document.getElementById('scoreDisplay').textContent = gameState.score;
                toggleTheme(); // Apply the loaded theme
            }
        }

        function showError(message, duration = 3000) {
            const errorMsg = document.getElementById('errorMsg');
            errorMsg.textContent = message;
            errorMsg.style.display = 'block';
            setTimeout(() => {
                errorMsg.style.display = 'none';
            }, duration);
        }

        window.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>
